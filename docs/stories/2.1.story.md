# Story 2.1: WebSocket Service & Connection Management

## Status: Ready for TDD Development

## Story

- As a **developer**
- I want **to create a complete WebSocket service with BLoC integration and connection management**
- so that **the application can establish, maintain, and manage WebSocket connections to the backend**

## Pre-Development Test Planning

### **Test Strategy**
- [ ] **Test Approach Defined**: Unit tests for WebSocket service, Widget tests for connection status UI, Integration tests for BLoC workflow
- [ ] **Mock Strategy**: Mock WebSocket channels, Mock network connectivity, Mock timers for timeout/retry testing
- [ ] **Test Data**: Sample connection responses, Mock error scenarios, Test connection configurations
- [ ] **Test Environment**: Network simulation with connection/disconnection scenarios

### **TDD Development Plan**
```markdown
1. **RED Phase Tests**: List of failing tests to write first
   - [ ] Test 1: WebSocket service connection management tests
   - [ ] Test 2: Connection timeout and retry logic tests
   - [ ] Test 3: BLoC WebSocket state management tests
   - [ ] Test 4: Auto-connection and lifecycle tests
   
2. **GREEN Phase Implementation**: Minimal code to pass tests
   - [ ] Implementation 1: Basic WebSocket service with connection handling
   - [ ] Implementation 2: Timeout and retry logic implementation
   - [ ] Implementation 3: BLoC integration with WebSocket states
   - [ ] Implementation 4: Auto-connection and UI status integration
   
3. **REFACTOR Phase**: Code quality improvements
   - [ ] Refactor 1: Optimize WebSocket service architecture and performance
   - [ ] Refactor 2: Improve connection reliability and error handling
   - [ ] Refactor 3: Enhance BLoC WebSocket integration patterns
   - [ ] Refactor 4: Clean up auto-connection and lifecycle management
```

## Acceptance Criteria (TDD Format)

### AC1: WebSocket Service Foundation
**Given** the WebSocket service is initialized  
**When** connection is requested to backend URL  
**Then** service should establish WebSocket connection  
**And** connection lifecycle should be properly managed

**Test Scenarios:**
- [ ] **Happy Path**: Service connects successfully to backend WebSocket
- [ ] **Error Case**: Connection failures are handled with proper error states
- [ ] **Edge Case**: Multiple connection attempts are handled gracefully

**Test Implementation Required:**
- [ ] **Unit Test**: WebSocket service connection logic and lifecycle management
- [ ] **Widget Test**: Connection status display in UI components
- [ ] **Integration Test**: End-to-end WebSocket service connection workflow

### AC2: Connection Timeout & Retry Logic
**Given** WebSocket connection is attempted  
**When** connection takes longer than 30 seconds  
**Then** connection should timeout and trigger retry logic  
**And** retry attempts should follow exponential backoff pattern

**Test Scenarios:**
- [ ] **Happy Path**: Timeout triggers retry with proper delay intervals
- [ ] **Error Case**: Maximum retry attempts reached, service enters failed state
- [ ] **Edge Case**: Connection succeeds during retry attempts

**Test Implementation Required:**
- [ ] **Unit Test**: Timeout logic and retry mechanism behavior
- [ ] **Widget Test**: Timeout/retry status display in UI
- [ ] **Integration Test**: Complete timeout and retry workflow testing

### AC3: BLoC WebSocket Integration
**Given** WebSocket service operations occur  
**When** connection status changes  
**Then** BLoC should emit appropriate state updates  
**And** UI should reflect current connection status

**Test Scenarios:**
- [ ] **Happy Path**: Connection status changes trigger correct BLoC state transitions
- [ ] **Error Case**: Connection errors are properly captured and handled in BLoC
- [ ] **Edge Case**: Rapid connection state changes are handled correctly

**Test Implementation Required:**
- [ ] **Unit Test**: BLoC WebSocket state management and event handling
- [ ] **Widget Test**: UI components responding to WebSocket state changes
- [ ] **Integration Test**: Complete WebSocket-BLoC-UI integration workflow

### AC4: Auto-Connection & Lifecycle Management
**Given** camera is initialized and ready  
**When** camera reaches ready state  
**Then** WebSocket connection should be automatically initiated  
**And** connection should be properly managed through app lifecycle

**Test Scenarios:**
- [ ] **Happy Path**: Auto-connection triggers after camera ready state
- [ ] **Error Case**: Auto-connection failures don't prevent camera functionality
- [ ] **Edge Case**: App backgrounding/foregrounding handles WebSocket correctly

**Test Implementation Required:**
- [ ] **Unit Test**: Auto-connection logic and lifecycle management
- [ ] **Widget Test**: Auto-connection status indicators in UI
- [ ] **Integration Test**: Complete camera-to-WebSocket auto-connection workflow

## Story Estimation

**Story Points**: 16 SP (increased from 12 SP for TDD)  
**Complexity**: High - Network layer + state management + BLoC integration + Connection lifecycle + TDD implementation  
**Risk Level**: Medium - External service dependency, network reliability, state synchronization, WebSocket testing complexity  
**TDD Effort**: 4 SP additional for comprehensive WebSocket testing, network mocking, and timing-sensitive tests  
**Estimation Method**: Combined estimation from service foundation and BLoC integration + TDD overhead  
**Reference Stories**: WebSocket service implementations + TDD experience from Stories 1.1, 1.2, 1.3  
**Assumptions**: Backend WebSocket service is stable, BLoC foundation ready (Story 1.1), camera ready state available (Story 1.2), TDD tooling configured

## Tasks / Subtasks

### **Phase 1: TDD Pre-Development**
- [ ] **Task 1**: WebSocket Test Strategy & Mock Setup
  - [ ] Design WebSocket testing strategy with channel mocking
  - [ ] Setup mock WebSocket channels for reliable testing
  - [ ] Prepare network connectivity simulation
  - [ ] Create test fixtures for connection scenarios and timeouts
  - [ ] Document WebSocket testing approach and network simulation

### **Phase 2: TDD Development (RED-GREEN-REFACTOR)**

#### **Task 2: WebSocket Service Foundation - TDD Cycle**
**ðŸ”´ RED Phase:**
- [ ] Write failing tests for WebSocket service initialization
- [ ] Write failing tests for connection establishment
- [ ] Write failing tests for connection lifecycle management
- [ ] Write failing tests for service configuration

**ðŸŸ¢ GREEN Phase:**
- [ ] Create WebSocketService with basic connection handling
- [ ] Implement connection state management with status tracking
- [ ] Add service configuration with URL and settings
- [ ] Create connection lifecycle methods (connect, disconnect, dispose)

**ðŸ”µ REFACTOR Phase:**
- [ ] Optimize WebSocket service architecture and patterns
- [ ] Improve connection state management efficiency
- [ ] Enhance service configuration and flexibility
- [ ] Clean up connection lifecycle and error handling

#### **Task 3: Connection Timeout & Retry Logic - TDD Cycle**
**ðŸ”´ RED Phase:**
- [ ] Write failing tests for 30-second connection timeout
- [ ] Write failing tests for retry logic with exponential backoff
- [ ] Write failing tests for maximum retry attempts handling
- [ ] Write failing tests for timeout error states

**ðŸŸ¢ GREEN Phase:**
- [ ] Implement 30-second connection timeout mechanism
- [ ] Add retry logic with configurable attempts and delays
- [ ] Create exponential backoff for retry intervals
- [ ] Handle timeout and retry error states

**ðŸ”µ REFACTOR Phase:**
- [ ] Optimize timeout and retry logic performance
- [ ] Improve retry strategy and backoff algorithms
- [ ] Enhance timeout error handling and recovery
- [ ] Clean up timeout and retry code structure

#### **Task 4: Message Handling & API - TDD Cycle**
**ðŸ”´ RED Phase:**
- [ ] Write failing tests for message sending functionality
- [ ] Write failing tests for message receiving streams
- [ ] Write failing tests for connection validation
- [ ] Write failing tests for connection management API

**ðŸŸ¢ GREEN Phase:**
- [ ] Implement message sending with error handling
- [ ] Create message receiving streams for UI updates
- [ ] Add connection validation and health checks
- [ ] Build connection management API (connect, disconnect, etc.)

**ðŸ”µ REFACTOR Phase:**
- [ ] Optimize message handling performance
- [ ] Improve message streaming and error handling
- [ ] Enhance connection API reliability
- [ ] Clean up message handling architecture

#### **Task 5: BLoC WebSocket Integration - TDD Cycle**
**ðŸ”´ RED Phase:**
- [ ] Write failing tests for WebSocket state integration
- [ ] Write failing tests for connection status events
- [ ] Write failing tests for WebSocket event handling
- [ ] Write failing tests for service-BLoC bridge

**ðŸŸ¢ GREEN Phase:**
- [ ] Extend CheckInState with WebSocket connection states
- [ ] Add WebSocket-related events to CheckInEvent
- [ ] Implement connection state transitions in CheckInBloc
- [ ] Create service-BLoC integration bridge

**ðŸ”µ REFACTOR Phase:**
- [ ] Optimize BLoC WebSocket state management
- [ ] Improve event handling and state transitions
- [ ] Enhance service-BLoC integration patterns
- [ ] Clean up WebSocket BLoC architecture

#### **Task 6: Auto-Connection & Lifecycle - TDD Cycle**
**ðŸ”´ RED Phase:**
- [ ] Write failing tests for auto-connection after camera ready
- [ ] Write failing tests for connection dependency logic
- [ ] Write failing tests for app lifecycle handling
- [ ] Write failing tests for connection sequencing

**ðŸŸ¢ GREEN Phase:**
- [ ] Implement auto-connection triggered by camera ready state
- [ ] Add connection dependency logic (camera â†’ WebSocket)
- [ ] Handle app backgrounding/foregrounding for WebSocket
- [ ] Ensure proper connection sequencing and timing

**ðŸ”µ REFACTOR Phase:**
- [ ] Optimize auto-connection logic and timing
- [ ] Improve lifecycle management and state handling
- [ ] Enhance connection dependency management
- [ ] Clean up auto-connection and lifecycle code

### **Phase 3: TDD Comprehensive Testing**
- [ ] **Task 7**: Integration & Network Testing
  - [ ] Add integration tests for complete WebSocket workflow
  - [ ] Add network simulation tests for various connection scenarios
  - [ ] Add performance tests for connection handling under load
  - [ ] Verify test coverage meets 80% minimum for WebSocket code

### **Phase 4: Documentation & Review**
- [ ] **Task 8**: WebSocket Documentation & Debug Integration
  - [ ] Document WebSocket service architecture and usage patterns
  - [ ] Add connection status logging to debug view
  - [ ] Create WebSocket troubleshooting guide
  - [ ] Prepare WebSocket service for frame streaming integration (Story 2.2)

- [ ] Task 1: Create WebSocket Service Foundation
  - [ ] Implement WebSocketService in core/services/
  - [ ] Create service configuration (URL, timeout, retry settings)
  - [ ] Implement singleton pattern for global access
  - [ ] Add service initialization and disposal methods
  - [ ] Create service interface for testing

- [ ] Task 2: Implement Connection State Management
  - [ ] Create connection state enum (disconnected, connecting, connected, failed)
  - [ ] Implement connection state tracking
  - [ ] Add connection state stream for UI updates
  - [ ] Handle connection state transitions
  - [ ] Create connection status logging

- [ ] Task 3: Add Connection Timeout Handling
  - [ ] Implement 30-second connection timeout
  - [ ] Handle timeout scenarios appropriately
  - [ ] Add timeout error states and recovery
  - [ ] Log timeout events for debugging
  - [ ] Test timeout functionality

- [ ] Task 4: Implement Retry Logic Foundation
  - [ ] Create retry configuration (attempts, delays)
  - [ ] Implement retry state management
  - [ ] Add retry attempt tracking
  - [ ] Create exponential backoff logic
  - [ ] Test retry scenarios

### **Phase 2: Connection Management API (ACs: 7, 10)**

- [ ] Task 5: Create Connection Management API
  - [ ] Implement connect() method with error handling
  - [ ] Implement disconnect() method with cleanup
  - [ ] Add connection validation logic
  - [ ] Create connection utility methods
  - [ ] Test connection API methods

- [ ] Task 6: Add Service Configuration
  - [ ] Create WebSocket configuration class with URL: `ws://192.168.1.234:3009`
  - [ ] Add environment-specific URL handling (dev/staging/prod)
  - [ ] Implement configurable timeout (30s) and retry settings (3 attempts, 3s delay)
  - [ ] Add service feature flags
  - [ ] Test configuration options with real backend

### **Phase 3: BLoC Integration & State Management (ACs: 2, 5, 8, 12)**

- [ ] Task 7: BLoC State Integration
  - [ ] Extend CheckInState to include WebSocket connection states
  - [ ] Add WebSocket-related events to CheckInEvent
  - [ ] Implement connection state transitions in CheckInBloc
  - [ ] Add connection status tracking through BLoC
  - [ ] Test state transitions and UI updates

- [ ] Task 8: WebSocket Event Handling
  - [ ] Implement connection request events
  - [ ] Add connection status change events
  - [ ] Handle connection error events
  - [ ] Add message sending/receiving events
  - [ ] Test event flow through BLoC

- [ ] Task 9: Service-BLoC Bridge
  - [ ] Create WebSocket service integration layer
  - [ ] Implement service status â†’ BLoC state mapping
  - [ ] Add service event â†’ BLoC event bridging
  - [ ] Ensure proper service lifecycle through BLoC
  - [ ] Test integration and state synchronization

### **Phase 4: Auto-Connection & UI Integration (ACs: 8, 11, 12)**

- [ ] Task 10: Auto-Connection Implementation
  - [ ] Implement auto-connection after camera ready
  - [ ] Add connection dependency logic (camera â†’ WebSocket)
  - [ ] Handle auto-connection error scenarios
  - [ ] Test auto-connection flow
  - [ ] Ensure proper connection sequencing

- [ ] Task 11: Debug Integration & Monitoring
  - [ ] Add WebSocket status logging to debug view
  - [ ] Implement connection attempt tracking
  - [ ] Add connection metrics to debug display
  - [ ] Create connection health monitoring
  - [ ] Test debug information accuracy

- [ ] Task 12: Final Integration & Validation
  - [ ] Integrate WebSocket service with check-in screen
  - [ ] Test complete connection management flow
  - [ ] Validate connection reliability and recovery
  - [ ] Ensure seamless BLoC state integration
  - [ ] Prepare for frame streaming integration (next story)

## Dev Technical Guidance

### WebSocket Service Architecture
```dart
// Complete WebSocket service structure
class WebSocketService {
  static final WebSocketService _instance = WebSocketService._internal();
  factory WebSocketService() => _instance;
  
  WebSocketChannel? _channel;
  StreamSubscription? _subscription;
  Timer? _timeoutTimer;
  Timer? _retryTimer;
  int _retryAttempts = 0;
  
  // Configuration
  WebSocketConfig _config = WebSocketConfig.development;
  
  // Connection management
  Future<void> connect(String url);
  Future<void> disconnect();
  void dispose();
  
  // Message handling
  void sendMessage(dynamic message);
  Stream<dynamic> get messageStream;
  
  // State streams
  Stream<ConnectionStatus> get connectionStatusStream;
  
  // Service health
  ConnectionMetrics get metrics;
}

enum ConnectionStatus {
  disconnected,
  connecting,
  connected,
  failed,
  timeout,
  retrying
}
```

### BLoC Integration Pattern
```dart
// Extended CheckInState for WebSocket
@freezed
class CheckInState with _$CheckInState {
  const factory CheckInState({
    @Default(CameraStatus.initial) CameraStatus cameraStatus,
    @Default(PermissionStatus.initial) PermissionStatus permissionStatus,
    @Default(ConnectionStatus.disconnected) ConnectionStatus connectionStatus,
    @Default(StreamingStatus.idle) StreamingStatus streamingStatus,
    @Default(false) bool isLoading,
    String? errorMessage,
    CameraController? cameraController,
    // WebSocket specific state
    @Default(0) int connectionAttempts,
    DateTime? lastConnectionAttempt,
    String? connectionError,
    // Toast-related state
    @Default(ToastStatus.none) ToastStatus toastStatus,
    String? toastMessage,
  }) = _CheckInState;
}
```

### WebSocket Events Extension
```dart
// Extended CheckInEvent for WebSocket
@freezed
class CheckInEvent with _$CheckInEvent {
  // Existing events...
  
  // WebSocket connection events
  const factory CheckInEvent.webSocketConnectionRequested() = WebSocketConnectionRequested;
  const factory CheckInEvent.webSocketConnecting() = WebSocketConnecting;
  const factory CheckInEvent.webSocketConnected() = WebSocketConnected;
  const factory CheckInEvent.webSocketDisconnected() = WebSocketDisconnected;
  const factory CheckInEvent.webSocketConnectionFailed(String error) = WebSocketConnectionFailed;
  const factory CheckInEvent.webSocketConnectionTimeout() = WebSocketConnectionTimeout;
  const factory CheckInEvent.webSocketRetrying(int attempt) = WebSocketRetrying;
  
  // WebSocket message events
  const factory CheckInEvent.webSocketMessageReceived(dynamic message) = WebSocketMessageReceived;
  const factory CheckInEvent.webSocketMessageSent(dynamic message) = WebSocketMessageSent;
  const factory CheckInEvent.webSocketSendError(String error) = WebSocketSendError;
}
```

### Service Configuration
```dart
class WebSocketConfig {
  final String url;
  final Duration timeout;
  final int maxRetries;
  final Duration retryDelay;
  final bool enableLogging;
  final bool enableHeartbeat;
  final Duration heartbeatInterval;
  
  const WebSocketConfig({
    required this.url,
    this.timeout = const Duration(seconds: 30),
    this.maxRetries = 3,
    this.retryDelay = const Duration(seconds: 3),
    this.enableLogging = true,
    this.enableHeartbeat = false,
    this.heartbeatInterval = const Duration(seconds: 30),
  });
  
  // Development configuration
  static const WebSocketConfig development = WebSocketConfig(
    url: 'ws://192.168.1.234:3009',
    timeout: Duration(seconds: 30),
    maxRetries = 3,
    retryDelay: Duration(seconds: 3),
    enableLogging: true,
    enableHeartbeat: true,
  );
}
```

### Connection Management Implementation
```dart
// Connection management with retry logic
class ConnectionManager {
  static Future<void> connectWithRetry(WebSocketService service) async {
    int attempts = 0;
    const maxAttempts = 3;
    
    while (attempts < maxAttempts) {
      try {
        await service.connect();
        return; // Success
      } catch (e) {
        attempts++;
        if (attempts < maxAttempts) {
          await Future.delayed(Duration(seconds: 3 * attempts));
        } else {
          throw ConnectionException('Failed after $maxAttempts attempts: $e');
        }
      }
    }
  }
}
```

### Auto-Connection Logic
```dart
// Auto-connection after camera ready
class AutoConnectionManager {
  static void listenForCameraReady(CheckInBloc bloc) {
    bloc.stream.listen((state) {
      if (state.cameraStatus == CameraStatus.ready && 
          state.connectionStatus == ConnectionStatus.disconnected) {
        bloc.add(const CheckInEvent.webSocketConnectionRequested());
      }
    });
  }
}
```

### Service Specifications
- **WebSocket URL**: Configurable backend URL (ws://192.168.1.234:3009 for development)
- **Connection Timeout**: 30 seconds maximum
- **Retry Policy**: 3 attempts with exponential backoff (3s, 6s, 9s)
- **State Management**: Full integration with BLoC state machine
- **Auto-Connection**: Triggered when camera becomes ready

### Error Handling Strategy
- **Network Errors**: Categorize and handle appropriately with retry logic
- **Timeout Errors**: Specific timeout handling with user feedback
- **Configuration Errors**: Validate URLs and settings before connection
- **Service Errors**: Graceful service-level error handling with recovery
- **State Synchronization**: Ensure BLoC state matches actual service state

### Performance Considerations
- **Resource Management**: Proper disposal of connections and timers
- **Memory Leaks**: Careful subscription management and cleanup
- **Connection Pooling**: Efficient connection reuse where possible
- **Background Behavior**: Handle app backgrounding gracefully
- **Network Optimization**: Minimize unnecessary connection attempts

### Testing Strategy
- **Unit Tests**: Test service logic independently with mocks
- **Mock Tests**: Test with mock WebSocket connections
- **Error Tests**: Test various failure conditions and recovery
- **Timeout Tests**: Verify timeout behavior and recovery
- **Configuration Tests**: Test different config scenarios
- **Integration Tests**: Test BLoC integration and state synchronization
- **Auto-Connection Tests**: Test camera â†’ WebSocket dependency flow

### Integration Points
- **Camera Service**: WebSocket connects after camera ready
- **Frame Streaming**: Foundation for frame transmission (next story)
- **Debug View**: Connection status and metrics displayed
- **UI Feedback**: Connection status shown through BLoC state
- **Error System**: WebSocket errors integrated with unified error handling

### Quality Standards
- **Connection Reliability**: Robust connection management with retry
- **State Consistency**: BLoC state always reflects actual connection status
- **Error Recovery**: Graceful recovery from all error conditions
- **Performance**: Efficient connection management without blocking UI
- **Monitoring**: Comprehensive logging and metrics for debugging

## Story Progress Notes

### Agent Model Used: `<To be filled by implementing agent>`

### Completion Notes List

*{Implementation notes will be filled by the implementing agent}*

### Change Log 

### **TDD-Specific Requirements**
- **Test Coverage**: Minimum 80% for WebSocket service, connection management, and BLoC integration
- **Test Quality**: WebSocket tests should handle network reliability and timing scenarios
- **Test Organization**: Separate unit tests for service logic, widget tests for UI components

### **TDD-Specific DoD**
- [ ] **Test-First Development**: All WebSocket features developed using TDD RED-GREEN-REFACTOR cycle
- [ ] **Test Coverage**: 80%+ coverage achieved for WebSocket service and BLoC integration
- [ ] **Test Quality**: WebSocket tests handle network reliability and timing scenarios properly
- [ ] **Test Documentation**: WebSocket testing strategy and network simulation documented 