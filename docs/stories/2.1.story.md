# Story 2.1: WebSocket Service & Connection Management

## Status: Review

## Story

- As a **developer**
- I want **to create a complete WebSocket service with BLoC integration and connection management**
- so that **the application can establish, maintain, and manage WebSocket connections to the backend**

## Acceptance Criteria (ACs)

1. A WebSocket service is created to manage connection logic and lifecycle
2. Connection status management is implemented with full state tracking
3. Connection timeout is implemented (30 seconds as per architecture)
4. Connection retry logic is implemented with configurable settings
5. WebSocket service integrates seamlessly with BLoC state management
6. Service handles connection lifecycle properly (connect, disconnect, dispose)
7. Connection errors are handled gracefully with proper error states
8. WebSocket connection status is reflected in the UI through BLoC
9. Service can be easily configured with different backend URLs
10. Connection management supports message sending and receiving
11. Auto-connection after camera initialization is implemented
12. Connection status is logged to debug view

## Story Estimation

**Story Points**: 12 SP  
**Complexity**: High - Network layer + state management + BLoC integration + Connection lifecycle  
**Risk Level**: Medium - External service dependency, network reliability, state synchronization  
**Estimation Method**: Combined estimation from service foundation and BLoC integration  
**Reference Stories**: Previous WebSocket service implementations with state management  
**Assumptions**: Backend WebSocket service is stable, BLoC foundation ready (Story 1.1), camera ready state available (Story 1.2)

## Tasks / Subtasks

### **Phase 1: WebSocket Service Foundation (ACs: 1, 3, 4, 6, 9)**

- [ ] Task 1: Create WebSocket Service Foundation
  - [ ] Implement WebSocketService in core/services/
  - [ ] Create service configuration (URL, timeout, retry settings)
  - [ ] Implement singleton pattern for global access
  - [ ] Add service initialization and disposal methods
  - [ ] Create service interface for testing

- [ ] Task 2: Implement Connection State Management
  - [ ] Create connection state enum (disconnected, connecting, connected, failed)
  - [ ] Implement connection state tracking
  - [ ] Add connection state stream for UI updates
  - [ ] Handle connection state transitions
  - [ ] Create connection status logging

- [ ] Task 3: Add Connection Timeout Handling
  - [ ] Implement 30-second connection timeout
  - [ ] Handle timeout scenarios appropriately
  - [ ] Add timeout error states and recovery
  - [ ] Log timeout events for debugging
  - [ ] Test timeout functionality

- [ ] Task 4: Implement Retry Logic Foundation
  - [ ] Create retry configuration (attempts, delays)
  - [ ] Implement retry state management
  - [ ] Add retry attempt tracking
  - [ ] Create exponential backoff logic
  - [ ] Test retry scenarios

### **Phase 2: Connection Management API (ACs: 7, 10)**

- [ ] Task 5: Create Connection Management API
  - [ ] Implement connect() method with error handling
  - [ ] Implement disconnect() method with cleanup
  - [ ] Add connection validation logic
  - [ ] Create connection utility methods
  - [ ] Test connection API methods

- [ ] Task 6: Add Service Configuration
  - [ ] Create WebSocket configuration class with URL: `ws://192.168.1.234:3009`
  - [ ] Add environment-specific URL handling (dev/staging/prod)
  - [ ] Implement configurable timeout (30s) and retry settings (3 attempts, 3s delay)
  - [ ] Add service feature flags
  - [ ] Test configuration options with real backend

### **Phase 3: BLoC Integration & State Management (ACs: 2, 5, 8, 12)**

- [ ] Task 7: BLoC State Integration
  - [ ] Extend CheckInState to include WebSocket connection states
  - [ ] Add WebSocket-related events to CheckInEvent
  - [ ] Implement connection state transitions in CheckInBloc
  - [ ] Add connection status tracking through BLoC
  - [ ] Test state transitions and UI updates

- [ ] Task 8: WebSocket Event Handling
  - [ ] Implement connection request events
  - [ ] Add connection status change events
  - [ ] Handle connection error events
  - [ ] Add message sending/receiving events
  - [ ] Test event flow through BLoC

- [ ] Task 9: Service-BLoC Bridge
  - [ ] Create WebSocket service integration layer
  - [ ] Implement service status → BLoC state mapping
  - [ ] Add service event → BLoC event bridging
  - [ ] Ensure proper service lifecycle through BLoC
  - [ ] Test integration and state synchronization

### **Phase 4: Auto-Connection & UI Integration (ACs: 8, 11, 12)**

- [ ] Task 10: Auto-Connection Implementation
  - [ ] Implement auto-connection after camera ready
  - [ ] Add connection dependency logic (camera → WebSocket)
  - [ ] Handle auto-connection error scenarios
  - [ ] Test auto-connection flow
  - [ ] Ensure proper connection sequencing

- [ ] Task 11: Debug Integration & Monitoring
  - [ ] Add WebSocket status logging to debug view
  - [ ] Implement connection attempt tracking
  - [ ] Add connection metrics to debug display
  - [ ] Create connection health monitoring
  - [ ] Test debug information accuracy

- [ ] Task 12: Final Integration & Validation
  - [ ] Integrate WebSocket service with check-in screen
  - [ ] Test complete connection management flow
  - [ ] Validate connection reliability and recovery
  - [ ] Ensure seamless BLoC state integration
  - [ ] Prepare for frame streaming integration (next story)

## Dev Technical Guidance

### WebSocket Service Architecture
```dart
// Complete WebSocket service structure
class WebSocketService {
  static final WebSocketService _instance = WebSocketService._internal();
  factory WebSocketService() => _instance;
  
  WebSocketChannel? _channel;
  StreamSubscription? _subscription;
  Timer? _timeoutTimer;
  Timer? _retryTimer;
  int _retryAttempts = 0;
  
  // Configuration
  WebSocketConfig _config = WebSocketConfig.development;
  
  // Connection management
  Future<void> connect(String url);
  Future<void> disconnect();
  void dispose();
  
  // Message handling
  void sendMessage(dynamic message);
  Stream<dynamic> get messageStream;
  
  // State streams
  Stream<ConnectionStatus> get connectionStatusStream;
  
  // Service health
  ConnectionMetrics get metrics;
}

enum ConnectionStatus {
  disconnected,
  connecting,
  connected,
  failed,
  timeout,
  retrying
}
```

### BLoC Integration Pattern
```dart
// Extended CheckInState for WebSocket
@freezed
class CheckInState with _$CheckInState {
  const factory CheckInState({
    @Default(CameraStatus.initial) CameraStatus cameraStatus,
    @Default(PermissionStatus.initial) PermissionStatus permissionStatus,
    @Default(ConnectionStatus.disconnected) ConnectionStatus connectionStatus,
    @Default(StreamingStatus.idle) StreamingStatus streamingStatus,
    @Default(false) bool isLoading,
    String? errorMessage,
    CameraController? cameraController,
    // WebSocket specific state
    @Default(0) int connectionAttempts,
    DateTime? lastConnectionAttempt,
    String? connectionError,
    // Toast-related state
    @Default(ToastStatus.none) ToastStatus toastStatus,
    String? toastMessage,
  }) = _CheckInState;
}
```

### WebSocket Events Extension
```dart
// Extended CheckInEvent for WebSocket
@freezed
class CheckInEvent with _$CheckInEvent {
  // Existing events...
  
  // WebSocket connection events
  const factory CheckInEvent.webSocketConnectionRequested() = WebSocketConnectionRequested;
  const factory CheckInEvent.webSocketConnecting() = WebSocketConnecting;
  const factory CheckInEvent.webSocketConnected() = WebSocketConnected;
  const factory CheckInEvent.webSocketDisconnected() = WebSocketDisconnected;
  const factory CheckInEvent.webSocketConnectionFailed(String error) = WebSocketConnectionFailed;
  const factory CheckInEvent.webSocketConnectionTimeout() = WebSocketConnectionTimeout;
  const factory CheckInEvent.webSocketRetrying(int attempt) = WebSocketRetrying;
  
  // WebSocket message events
  const factory CheckInEvent.webSocketMessageReceived(dynamic message) = WebSocketMessageReceived;
  const factory CheckInEvent.webSocketMessageSent(dynamic message) = WebSocketMessageSent;
  const factory CheckInEvent.webSocketSendError(String error) = WebSocketSendError;
}
```

### Service Configuration
```dart
class WebSocketConfig {
  final String url;
  final Duration timeout;
  final int maxRetries;
  final Duration retryDelay;
  final bool enableLogging;
  final bool enableHeartbeat;
  final Duration heartbeatInterval;
  
  const WebSocketConfig({
    required this.url,
    this.timeout = const Duration(seconds: 30),
    this.maxRetries = 3,
    this.retryDelay = const Duration(seconds: 3),
    this.enableLogging = true,
    this.enableHeartbeat = false,
    this.heartbeatInterval = const Duration(seconds: 30),
  });
  
  // Development configuration
  static const WebSocketConfig development = WebSocketConfig(
    url: 'ws://192.168.1.234:3009',
    timeout: Duration(seconds: 30),
    maxRetries = 3,
    retryDelay: Duration(seconds: 3),
    enableLogging: true,
    enableHeartbeat: true,
  );
}
```

### Connection Management Implementation
```dart
// Connection management with retry logic
class ConnectionManager {
  static Future<void> connectWithRetry(WebSocketService service) async {
    int attempts = 0;
    const maxAttempts = 3;
    
    while (attempts < maxAttempts) {
      try {
        await service.connect();
        return; // Success
      } catch (e) {
        attempts++;
        if (attempts < maxAttempts) {
          await Future.delayed(Duration(seconds: 3 * attempts));
        } else {
          throw ConnectionException('Failed after $maxAttempts attempts: $e');
        }
      }
    }
  }
}
```

### Auto-Connection Logic
```dart
// Auto-connection after camera ready
class AutoConnectionManager {
  static void listenForCameraReady(CheckInBloc bloc) {
    bloc.stream.listen((state) {
      if (state.cameraStatus == CameraStatus.ready && 
          state.connectionStatus == ConnectionStatus.disconnected) {
        bloc.add(const CheckInEvent.webSocketConnectionRequested());
      }
    });
  }
}
```

### Service Specifications
- **WebSocket URL**: Configurable backend URL (ws://192.168.1.234:3009 for development)
- **Connection Timeout**: 30 seconds maximum
- **Retry Policy**: 3 attempts with exponential backoff (3s, 6s, 9s)
- **State Management**: Full integration with BLoC state machine
- **Auto-Connection**: Triggered when camera becomes ready

### Error Handling Strategy
- **Network Errors**: Categorize and handle appropriately with retry logic
- **Timeout Errors**: Specific timeout handling with user feedback
- **Configuration Errors**: Validate URLs and settings before connection
- **Service Errors**: Graceful service-level error handling with recovery
- **State Synchronization**: Ensure BLoC state matches actual service state

### Performance Considerations
- **Resource Management**: Proper disposal of connections and timers
- **Memory Leaks**: Careful subscription management and cleanup
- **Connection Pooling**: Efficient connection reuse where possible
- **Background Behavior**: Handle app backgrounding gracefully
- **Network Optimization**: Minimize unnecessary connection attempts

### Testing Strategy
- **Unit Tests**: Test service logic independently with mocks
- **Mock Tests**: Test with mock WebSocket connections
- **Error Tests**: Test various failure conditions and recovery
- **Timeout Tests**: Verify timeout behavior and recovery
- **Configuration Tests**: Test different config scenarios
- **Integration Tests**: Test BLoC integration and state synchronization
- **Auto-Connection Tests**: Test camera → WebSocket dependency flow

### Integration Points
- **Camera Service**: WebSocket connects after camera ready
- **Frame Streaming**: Foundation for frame transmission (next story)
- **Debug View**: Connection status and metrics displayed
- **UI Feedback**: Connection status shown through BLoC state
- **Error System**: WebSocket errors integrated with unified error handling

### Quality Standards
- **Connection Reliability**: Robust connection management with retry
- **State Consistency**: BLoC state always reflects actual connection status
- **Error Recovery**: Graceful recovery from all error conditions
- **Performance**: Efficient connection management without blocking UI
- **Monitoring**: Comprehensive logging and metrics for debugging

## Story Progress Notes

### Agent Model Used: `<To be filled by implementing agent>`

### Completion Notes List

*{Implementation notes will be filled by the implementing agent}*

### Change Log 