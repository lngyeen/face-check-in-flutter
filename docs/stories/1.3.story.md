# Story 1.3: Implement Debug View

## Status: Ready for TDD Development

## Story

- As a **developer**
- I want **a simple, scrollable text view on the main screen**
- so that **I can log and observe internal states and messages during development**

## Pre-Development Test Planning

### **Test Strategy**
- [ ] **Test Approach Defined**: Unit tests for debug service, Widget tests for debug view, Integration tests for BLoC logging
- [ ] **Mock Strategy**: Mock stream controllers for debug messages, Mock build configuration flags
- [ ] **Test Data**: Sample debug messages, Mock timestamps, Test build environments
- [ ] **Test Environment**: Debug/Release build testing, Mock debug state management

### **TDD Development Plan**
```markdown
1. **RED Phase Tests**: List of failing tests to write first
   - [ ] Test 1: Debug log service message handling tests
   - [ ] Test 2: Debug view widget rendering and scrolling tests
   - [ ] Test 3: Compile-time flag conditional compilation tests
   - [ ] Test 4: BLoC debug integration and message emission tests
   
2. **GREEN Phase Implementation**: Minimal code to pass tests
   - [ ] Implementation 1: Basic debug log service with message streaming
   - [ ] Implementation 2: Debug view widget with scrollable text display
   - [ ] Implementation 3: Compile-time flag integration for production removal
   - [ ] Implementation 4: BLoC debug logging integration
   
3. **REFACTOR Phase**: Code quality improvements
   - [ ] Refactor 1: Optimize debug service performance and memory usage
   - [ ] Refactor 2: Improve debug view UI and user experience
   - [ ] Refactor 3: Clean up compile-time flag implementation
   - [ ] Refactor 4: Enhance BLoC debug logging patterns
```

## Acceptance Criteria (TDD Format)

### AC1: Debug View Widget Implementation
**Given** the app is running in debug mode  
**When** the check-in screen is displayed  
**Then** a scrollable debug view should appear at the bottom  
**And** debug view should not interfere with camera preview

**Test Scenarios:**
- [ ] **Happy Path**: Debug view renders correctly with proper layout constraints
- [ ] **Error Case**: Debug view handles empty or malformed messages gracefully
- [ ] **Edge Case**: Debug view adapts to different screen sizes appropriately

**Test Implementation Required:**
- [ ] **Unit Test**: Debug view layout and constraint handling
- [ ] **Widget Test**: Debug view rendering and scrolling behavior
- [ ] **Integration Test**: Debug view integration with main screen layout

### AC2: Debug Logging Service
**Given** the debug logging service is initialized  
**When** log messages are sent to the service  
**Then** messages should be formatted with timestamps and stored  
**And** messages should be available via stream for UI updates

**Test Scenarios:**
- [ ] **Happy Path**: Messages are logged with proper timestamps and formatting
- [ ] **Error Case**: Service handles high-frequency logging without performance issues
- [ ] **Edge Case**: Message buffer limits are respected to prevent memory issues

**Test Implementation Required:**
- [ ] **Unit Test**: Debug service message formatting and storage
- [ ] **Widget Test**: Debug view displaying streamed messages
- [ ] **Integration Test**: End-to-end logging from BLoC to debug view

### AC3: Production Build Removal
**Given** the app is compiled for production  
**When** build is created with release configuration  
**Then** debug view code should be completely excluded  
**And** no debug-related code should be present in release builds

**Test Scenarios:**
- [ ] **Happy Path**: Debug code is excluded in release builds
- [ ] **Error Case**: Build configuration errors are detected early
- [ ] **Edge Case**: Debug flags work correctly across different build types

**Test Implementation Required:**
- [ ] **Unit Test**: Compile-time flag behavior verification
- [ ] **Widget Test**: UI renders correctly without debug components in release
- [ ] **Integration Test**: Complete build verification for debug/release modes

### AC4: BLoC Debug Integration
**Given** BLoC operations are performed  
**When** state transitions or events occur  
**Then** debug messages should be automatically logged  
**And** debug information should help with development and troubleshooting

**Test Scenarios:**
- [ ] **Happy Path**: BLoC operations generate appropriate debug messages
- [ ] **Error Case**: Debug logging doesn't interfere with BLoC functionality
- [ ] **Edge Case**: High-frequency BLoC operations don't overwhelm debug view

**Test Implementation Required:**
- [ ] **Unit Test**: BLoC debug message generation and content
- [ ] **Widget Test**: Debug view showing BLoC-generated messages
- [ ] **Integration Test**: Complete BLoC-to-debug-view workflow

## Story Estimation

**Story Points**: 6 SP (increased from 2 SP for TDD)  
**Complexity**: Medium - Simple UI component + Basic logging integration + TDD implementation + Build configuration  
**Risk Level**: Low - Non-critical feature, straightforward implementation, TDD adds testing complexity  
**TDD Effort**: 4 SP additional for comprehensive testing, build configuration testing, and mock setup  
**Estimation Method**: Planning Poker consensus adjusted for TDD overhead and build testing  
**Reference Stories**: Debug/logging UI components + TDD experience from Stories 1.1 and 1.2  
**Assumptions**: Logging service provides structured data, debug view only needed in development, TDD tooling ready

## Tasks / Subtasks

### **Phase 1: TDD Pre-Development**
- [ ] **Task 1**: Debug Test Strategy & Mock Setup
  - [ ] Design debug testing strategy with stream mocking
  - [ ] Setup mock debug log service for testing
  - [ ] Prepare test fixtures for debug messages and timestamps
  - [ ] Create build configuration test environment
  - [ ] Document debug testing approach and limitations

### **Phase 2: TDD Development (RED-GREEN-REFACTOR)**

#### **Task 2: Debug Logging Service - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for debug message formatting
- [ ] Write failing tests for message storage and buffer management
- [ ] Write failing tests for stream-based message updates
- [ ] Write failing tests for different log levels

**游릭 GREEN Phase:**
- [ ] Create DebugLogService with basic message handling
- [ ] Implement message formatting with timestamps
- [ ] Add message buffer management (limit stored messages)
- [ ] Create stream-based updates for UI

**游댯 REFACTOR Phase:**
- [ ] Optimize debug service performance and memory usage
- [ ] Improve message formatting and readability
- [ ] Enhance stream handling and error management
- [ ] Clean up service architecture and patterns

#### **Task 3: Debug View Widget - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for debug view rendering
- [ ] Write failing tests for scrollable behavior
- [ ] Write failing tests for layout constraints
- [ ] Write failing tests for message display updates

**游릭 GREEN Phase:**
- [ ] Create DebugViewWidget with scrollable text area
- [ ] Implement auto-scroll to latest messages
- [ ] Add proper styling with monospace font
- [ ] Configure maximum height constraints

**游댯 REFACTOR Phase:**
- [ ] Optimize UI performance and scroll behavior
- [ ] Improve visual design and readability
- [ ] Enhance responsive layout handling
- [ ] Clean up widget structure and components

#### **Task 4: Compile-time Flag Integration - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for debug build inclusion
- [ ] Write failing tests for release build exclusion
- [ ] Write failing tests for build configuration detection
- [ ] Write failing tests for conditional compilation

**游릭 GREEN Phase:**
- [ ] Implement compile-time flags for debug view
- [ ] Add conditional compilation for debug widgets
- [ ] Configure build settings for debug/release modes
- [ ] Test both debug and release build configurations

**游댯 REFACTOR Phase:**
- [ ] Optimize build configuration setup
- [ ] Improve compile-time flag usage patterns
- [ ] Enhance build documentation and procedures
- [ ] Clean up conditional compilation code

#### **Task 5: BLoC Debug Integration - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for BLoC debug message generation
- [ ] Write failing tests for state transition logging
- [ ] Write failing tests for debug state management
- [ ] Write failing tests for performance impact verification

**游릭 GREEN Phase:**
- [ ] Add debug state to CheckInState if needed
- [ ] Create debug-related events in CheckInEvent
- [ ] Update CheckInBloc to emit debug messages
- [ ] Log state transitions and important events

**游댯 REFACTOR Phase:**
- [ ] Optimize BLoC debug integration performance
- [ ] Improve debug message content and formatting
- [ ] Enhance state transition logging patterns
- [ ] Clean up debug integration architecture

### **Phase 3: TDD Comprehensive Testing**
- [ ] **Task 6**: Integration & Build Testing
  - [ ] Add integration tests for complete debug workflow
  - [ ] Add build verification tests for debug/release modes
  - [ ] Add performance tests for debug service impact
  - [ ] Verify test coverage meets 80% minimum for debug code

### **Phase 4: Documentation & Review**
- [ ] **Task 7**: Debug System Documentation
  - [ ] Document debug system architecture and usage
  - [ ] Create debugging workflow guide for developers
  - [ ] Update build configuration documentation
  - [ ] Prepare debug integration for team handoff
  - [ ] Implement DebugViewWidget in features/check_in/widgets/
  - [ ] Create scrollable text area with fixed maximum height
  - [ ] Implement auto-scroll to latest messages
  - [ ] Style debug view with monospace font for readability
  - [ ] Add visual separation from camera preview area

- [ ] Task 2: Implement Debug Logging Service (AC: 2, 4, 5)
  - [ ] Create DebugLogService in core/services/
  - [ ] Implement message formatting with timestamps
  - [ ] Add different log levels (debug, info, warning, error)
  - [ ] Implement message buffer management (limit stored messages)
  - [ ] Create singleton pattern for global access

- [ ] Task 3: Integrate Debug View with BLoC (AC: 4)
  - [ ] Add debug state to CheckInState
  - [ ] Create debug-related events in CheckInEvent
  - [ ] Update CheckInBloc to emit debug messages
  - [ ] Log state transitions and important events
  - [ ] Ensure debug messages don't affect performance

- [ ] Task 4: Implement Production Build Removal (AC: 3)
  - [ ] Create compile-time flags for debug view
  - [ ] Implement conditional compilation for debug widgets
  - [ ] Ensure no debug code is included in release builds
  - [ ] Add build configuration documentation
  - [ ] Test both debug and release builds

- [ ] Task 5: Add Debug Toggle Functionality (AC: 7)
  - [ ] Implement debug view show/hide functionality
  - [ ] Add gesture or button to toggle debug view
  - [ ] Store debug view preference state
  - [ ] Ensure toggle only works in debug builds
  - [ ] Test toggle functionality

- [ ] Task 6: Main Screen Integration (AC: 1, 6)
  - [ ] Integrate DebugViewWidget into CheckInScreen
  - [ ] Position debug view at bottom of screen
  - [ ] Ensure proper layout constraints
  - [ ] Test with different screen sizes
  - [ ] Verify camera preview is not affected

## Dev Technical Guidance

### Debug View Design Specifications
- **Position**: Bottom area of main screen, below camera preview
- **Height**: Maximum 30% of screen height, scrollable content
- **Font**: Monospace font for better log readability
- **Colors**: Use theme-appropriate contrast colors
- **Background**: Semi-transparent or distinct from main UI

### Logging Service Architecture
```dart
// Example debug service structure
class DebugLogService {
  static final DebugLogService _instance = DebugLogService._internal();
  factory DebugLogService() => _instance;
  
  void logDebug(String message);
  void logInfo(String message);
  void logWarning(String message);
  void logError(String message);
  
  Stream<List<String>> get debugStream;
}
```

### Compile-Time Flag Implementation
```dart
// Use kDebugMode or custom debug flags
Widget build(BuildContext context) {
  return Column(
    children: [
      CameraPreviewWidget(),
      if (kDebugMode) DebugViewWidget(),
    ],
  );
}
```

### Debug Message Format
- **Timestamp**: `[HH:mm:ss.SSS]`
- **Level**: `[DEBUG/INFO/WARN/ERROR]`
- **Source**: `[BLoC/Service/Widget]`
- **Message**: Actual log content

### Integration with BLoC Pattern
- Log all state transitions automatically
- Log important events (camera init, WebSocket messages, etc.)
- Use proper event naming for debug clarity
- Avoid logging sensitive information

### Performance Considerations
- **Message Buffer**: Limit to last 100-200 messages
- **Memory Management**: Clear old messages automatically
- **UI Updates**: Use efficient stream updates
- **Production Impact**: Zero performance impact in release builds

### **TDD-Specific Requirements**
- **Test Coverage**: Minimum 80% for debug service and widget components
- **Test Quality**: Debug tests should verify build configuration and stream behavior
- **Test Organization**: Separate unit tests for service logic, widget tests for UI components
- **Mock Strategy**: Use stream mocking for debug messages and build configuration testing

### **Debug TDD Testing Patterns**
```dart
// Example TDD approach for debug testing
group('DebugLogService', () {
  late DebugLogService debugService;
  late StreamController<String> mockStreamController;

  setUp(() {
    mockStreamController = StreamController<String>();
    debugService = DebugLogService(streamController: mockStreamController);
  });

  // RED: Write failing test first
  test('should format message with timestamp', () {
    // arrange
    const message = 'Test debug message';
    
    // act
    debugService.logDebug(message);
    
    // assert
    expect(debugService.messages.last, 
           matches(r'\[\d{2}:\d{2}:\d{2}\.\d{3}\] \[DEBUG\] Test debug message'));
  });

  // Test message buffer management
  test('should limit stored messages to maximum count', () async {
    // arrange
    const maxMessages = 100;
    
    // act
    for (int i = 0; i < 150; i++) {
      debugService.logDebug('Message $i');
    }
    
    // assert
    expect(debugService.messages.length, equals(maxMessages));
    expect(debugService.messages.first, contains('Message 50'));
  });
});

// Widget testing for debug view
group('DebugViewWidget', () {
  testWidgets('should display debug messages in scrollable view', (tester) async {
    // arrange
    final mockDebugService = MockDebugLogService();
    when(() => mockDebugService.debugStream).thenAnswer(
      (_) => Stream.fromIterable([['Test message 1', 'Test message 2']]),
    );
    
    // act
    await tester.pumpWidget(
      MaterialApp(
        home: DebugViewWidget(debugService: mockDebugService),
      ),
    );
    
    // assert
    expect(find.text('Test message 1'), findsOneWidget);
    expect(find.byType(ListView), findsOneWidget);
  });
});

// Build configuration testing
group('Debug Build Configuration', () {
  test('should exclude debug widget in release builds', () {
    // This test would verify compile-time flag behavior
    // Implementation depends on build configuration testing strategy
  });
});
```

### **Quality Standards**
- **Debug Service**: Efficient message handling and memory management
- **UI Performance**: Debug view doesn't impact app performance
- **Build Integration**: Clean separation between debug and release builds
- **Developer Experience**: Clear and useful debug information display
- **Testing**: Complete TDD coverage with build configuration verification

## Definition of Done Checklist

### **TDD-Specific DoD**
- [ ] **Test-First Development**: All debug features developed using TDD RED-GREEN-REFACTOR cycle
- [ ] **Test Coverage**: 80%+ coverage achieved for debug service and widget components
- [ ] **Test Quality**: Debug tests verify stream behavior and build configuration properly
- [ ] **Test Documentation**: Debug testing strategy and build testing documented
- [ ] **Mock Strategy**: Debug service and build configuration properly mocked for testing

### **Standard DoD**
- [ ] **Code Review**: Reviewed by team member with debug system and TDD experience
- [ ] **Integration**: Debug system seamlessly integrated with BLoC and app architecture
- [ ] **Documentation**: Debug system usage and build configuration documented
- [ ] **Build Verification**: Debug/release builds verified to work correctly
- [ ] **Performance**: Debug system has zero impact on release build performance

### **Story-Specific Requirements**
- [ ] **Debug View Display**: Scrollable debug view appears correctly in debug builds only
- [ ] **Message Logging**: Debug service handles messages with proper formatting and timestamps
- [ ] **Build Configuration**: Debug code completely excluded from release builds
- [ ] **BLoC Integration**: Debug logging integrated with BLoC state transitions and events
- [ ] **Memory Management**: Debug service respects message buffer limits
- [ ] **Developer Workflow**: Debug view enhances development and troubleshooting experience

### **Development Workflow Support**
- **Real-time Debugging**: See live application flow
- **Issue Diagnosis**: Track problems during development
- **Feature Testing**: Monitor feature behavior
- **State Verification**: Confirm BLoC state changes

### **Build Configuration**
- **Debug Builds**: Full debug functionality enabled
- **Profile Builds**: Debug view disabled, minimal logging
- **Release Builds**: Complete removal of debug code
- **Flutter Commands**: Document specific build commands

## Story Progress Notes

### Agent Model Used: `<To be filled by implementing agent>`

### Completion Notes List

*{Implementation notes will be filled by the implementing agent}*

### Change Log
