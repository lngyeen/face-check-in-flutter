# Story 1.2: Camera Integration & Permissions

## Status: Ready for TDD Development

## Story

- As a **user**
- I want **the app to automatically initialize the camera with proper permissions and display a live preview**
- so that **I can see myself on screen and the app is ready for face recognition**

## Pre-Development Test Planning

### **Test Strategy**
- [ ] **Test Approach Defined**: Unit tests for camera service, Widget tests for preview components, Integration tests for permission flow
- [ ] **Mock Strategy**: Mock camera controller, Mock permission handler, Mock platform channels
- [ ] **Test Data**: Sample camera frames, Mock permission states, Test camera configurations
- [ ] **Test Environment**: Camera testing with fake camera controller and permission simulation

### **TDD Development Plan**
```markdown
1. **RED Phase Tests**: List of failing tests to write first
   - [ ] Test 1: Camera permission request and handling tests
   - [ ] Test 2: Camera controller initialization tests
   - [ ] Test 3: Camera preview widget rendering tests
   - [ ] Test 4: BLoC camera state management tests
   
2. **GREEN Phase Implementation**: Minimal code to pass tests
   - [ ] Implementation 1: Basic permission handling with status tracking
   - [ ] Implementation 2: Camera controller setup with initialization logic
   - [ ] Implementation 3: Camera preview widget with basic display
   - [ ] Implementation 4: BLoC integration with camera state management
   
3. **REFACTOR Phase**: Code quality improvements
   - [ ] Refactor 1: Optimize permission handling and error recovery
   - [ ] Refactor 2: Improve camera lifecycle management
   - [ ] Refactor 3: Enhance preview quality and performance
   - [ ] Refactor 4: Clean up BLoC camera state transitions
```

## Acceptance Criteria (TDD Format)

### AC1: Camera Permission Handling
**Given** the app is launched for the first time  
**When** user accesses the check-in screen  
**Then** camera permission should be requested automatically  
**And** permission status should be tracked in app state

**Test Scenarios:**
- [ ] **Happy Path**: Permission granted, camera initializes successfully
- [ ] **Error Case**: Permission denied, user guidance displayed with retry option
- [ ] **Edge Case**: Permission permanently denied, settings redirect provided

**Test Implementation Required:**
- [ ] **Unit Test**: Permission service behavior and status management
- [ ] **Widget Test**: Permission dialog display and user guidance
- [ ] **Integration Test**: End-to-end permission flow with camera initialization

### AC2: Live Camera Preview Display
**Given** camera permissions are granted  
**When** camera is initialized successfully  
**Then** live camera preview should be displayed in the main area  
**And** preview should maintain proper aspect ratio and quality

**Test Scenarios:**
- [ ] **Happy Path**: Preview displays correctly with proper scaling
- [ ] **Error Case**: Camera initialization fails, error state shown
- [ ] **Edge Case**: Different screen sizes handled appropriately

**Test Implementation Required:**
- [ ] **Unit Test**: Camera controller initialization and configuration
- [ ] **Widget Test**: Camera preview widget rendering and layout
- [ ] **Integration Test**: Camera preview integration with app UI

### AC3: BLoC State Management Integration
**Given** camera service is available  
**When** camera operations are performed  
**Then** all camera states should be managed through BLoC  
**And** state transitions should be properly tracked and logged

**Test Scenarios:**
- [ ] **Happy Path**: Camera states transition correctly through BLoC
- [ ] **Error Case**: Error states are captured and handled in BLoC
- [ ] **Edge Case**: Rapid state changes are handled gracefully

**Test Implementation Required:**
- [ ] **Unit Test**: BLoC camera state transitions and event handling
- [ ] **Widget Test**: UI components responding to camera state changes
- [ ] **Integration Test**: Complete camera-BLoC integration workflow

### AC4: Camera Lifecycle Management
**Given** camera is initialized and running  
**When** app lifecycle changes occur (background/foreground)  
**Then** camera should pause/resume appropriately  
**And** resources should be managed efficiently

**Test Scenarios:**
- [ ] **Happy Path**: Camera pauses/resumes with app lifecycle
- [ ] **Error Case**: Lifecycle errors handled gracefully
- [ ] **Edge Case**: Multiple rapid lifecycle changes handled correctly

**Test Implementation Required:**
- [ ] **Unit Test**: Camera lifecycle management logic
- [ ] **Widget Test**: UI state during lifecycle transitions
- [ ] **Integration Test**: End-to-end camera lifecycle with app states

## Story Estimation

**Story Points**: 19 SP (increased from 15 SP for TDD)  
**Complexity**: High - Camera hardware integration + Permissions + BLoC state management + Lifecycle handling + TDD implementation  
**Risk Level**: Medium - Device compatibility, permissions complexity, state synchronization, camera testing challenges  
**TDD Effort**: 4 SP additional for comprehensive camera testing and mock setup  
**Estimation Method**: Expert judgment based on camera integration complexity + TDD overhead + testing complexity  
**Reference Stories**: Camera hardware integration + state management + TDD pilot experience from Story 1.1  
**Assumptions**: BLoC foundation is ready (Story 1.1), target devices have camera capability, permissions framework available, TDD tooling setup complete

## Tasks / Subtasks

### **Phase 1: TDD Pre-Development**
- [ ] **Task 1**: Camera Test Strategy & Mock Setup
  - [ ] Design camera testing strategy with mock controllers
  - [ ] Setup fake camera controller for testing environment
  - [ ] Prepare mock permission handler for different scenarios
  - [ ] Create test fixtures for camera states and frames
  - [ ] Document camera testing approach and limitations

### **Phase 2: TDD Development (RED-GREEN-REFACTOR)**

#### **Task 2: Camera Permission Handling - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for permission request logic
- [ ] Write failing tests for permission status tracking
- [ ] Write failing tests for permission denied scenarios
- [ ] Write failing tests for BLoC permission state integration

**游릭 GREEN Phase:**
- [ ] Implement basic permission request using permission_handler
- [ ] Add permission status checking and tracking
- [ ] Create permission denied user guidance logic
- [ ] Integrate permission states with CheckInBloc

**游댯 REFACTOR Phase:**
- [ ] Optimize permission flow and error handling
- [ ] Improve user guidance and messaging
- [ ] Enhance permission state management
- [ ] Clean up permission service architecture

#### **Task 3: Camera Controller & Service - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for camera controller initialization
- [ ] Write failing tests for camera availability checking
- [ ] Write failing tests for camera configuration
- [ ] Write failing tests for camera error handling

**游릭 GREEN Phase:**
- [ ] Create camera controller with appropriate resolution
- [ ] Implement camera initialization logic with error handling
- [ ] Add camera availability checking functionality
- [ ] Configure camera settings for optimal quality

**游댯 REFACTOR Phase:**
- [ ] Optimize camera initialization performance
- [ ] Improve camera configuration management
- [ ] Enhance error handling and recovery
- [ ] Clean up camera service architecture

#### **Task 4: Camera Preview Widget - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for camera preview rendering
- [ ] Write failing tests for aspect ratio handling
- [ ] Write failing tests for different camera states
- [ ] Write failing tests for preview quality optimization

**游릭 GREEN Phase:**
- [ ] Create CameraPreviewWidget with basic display
- [ ] Implement proper aspect ratio and scaling
- [ ] Add camera state-based rendering logic
- [ ] Configure preview quality for recognition

**游댯 REFACTOR Phase:**
- [ ] Optimize preview performance and memory usage
- [ ] Improve UI responsiveness and layout
- [ ] Enhance preview quality and clarity
- [ ] Clean up widget structure and components

#### **Task 5: BLoC Camera Integration - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for camera state management
- [ ] Write failing tests for camera event handling
- [ ] Write failing tests for state transitions
- [ ] Write failing tests for error state propagation

**游릭 GREEN Phase:**
- [ ] Extend CheckInState with camera-specific states
- [ ] Add camera events to CheckInEvent structure
- [ ] Implement camera state transitions in CheckInBloc
- [ ] Add camera status tracking and logging

**游댯 REFACTOR Phase:**
- [ ] Optimize BLoC camera state architecture
- [ ] Improve event handling and state transitions
- [ ] Enhance error state management
- [ ] Clean up state management patterns

#### **Task 6: Camera Lifecycle Management - TDD Cycle**
**游댮 RED Phase:**
- [ ] Write failing tests for camera lifecycle events
- [ ] Write failing tests for app backgrounding/foregrounding
- [ ] Write failing tests for resource cleanup
- [ ] Write failing tests for lifecycle error scenarios

**游릭 GREEN Phase:**
- [ ] Implement camera start/stop lifecycle logic
- [ ] Add app lifecycle handling for camera
- [ ] Create pause/resume camera functionality
- [ ] Implement proper resource cleanup

**游댯 REFACTOR Phase:**
- [ ] Optimize camera lifecycle performance
- [ ] Improve resource management efficiency
- [ ] Enhance lifecycle error handling
- [ ] Clean up lifecycle management code

### **Phase 3: TDD Comprehensive Testing**
- [ ] **Task 7**: Edge Cases & Integration Testing
  - [ ] Add tests for device-specific camera issues
  - [ ] Add integration tests for camera-BLoC workflow
  - [ ] Add performance tests for camera operations
  - [ ] Verify test coverage meets 80% minimum for camera code

### **Phase 4: Documentation & Review**
- [ ] **Task 8**: Camera Test Documentation
  - [ ] Document camera testing strategy and limitations
  - [ ] Create camera integration troubleshooting guide
  - [ ] Update technical documentation with camera patterns
  - [ ] Prepare camera service for WebSocket integration (Story 2.2)

- [ ] Task 1: Implement Permission Handling
  - [ ] Add camera permission request logic using permission_handler
  - [ ] Implement permission status checking
  - [ ] Handle permission denied scenarios with user guidance
  - [ ] Add permission status logging to debug view
  - [ ] Test permission flow on both platforms

- [ ] Task 2: Camera Controller Initialization
  - [ ] Create camera controller with appropriate resolution
  - [ ] Implement camera initialization logic
  - [ ] Add camera availability checking
  - [ ] Handle camera initialization errors
  - [ ] Test on multiple device types

### **Phase 2: Camera Preview & Display (ACs: 2, 5, 10)**

- [ ] Task 3: Implement Camera Preview Widget
  - [ ] Create CameraPreviewWidget in features/check_in/widgets/
  - [ ] Implement live camera feed display
  - [ ] Ensure proper aspect ratio and scaling
  - [ ] Optimize preview quality for recognition
  - [ ] Test preview on different screen sizes

- [ ] Task 4: Camera Quality Optimization
  - [ ] Configure camera resolution for optimal recognition
  - [ ] Implement quality vs performance balancing
  - [ ] Add camera settings optimization
  - [ ] Test quality on various devices
  - [ ] Ensure recognition-suitable image quality

### **Phase 3: BLoC Integration & State Management (ACs: 3, 6, 8, 9)**

- [ ] Task 5: Camera State Management Integration
  - [ ] Extend CheckInState to include camera-specific states
  - [ ] Add camera-related events to CheckInEvent
  - [ ] Implement camera state transitions in CheckInBloc
  - [ ] Add camera status tracking and logging
  - [ ] Test state transitions and error handling

- [ ] Task 6: Camera Event Handling
  - [ ] Implement camera initialization events
  - [ ] Add camera permission events
  - [ ] Handle camera error events
  - [ ] Add camera streaming state events
  - [ ] Test event flow through BLoC

### **Phase 4: Lifecycle & Error Handling (ACs: 7, 8)**

- [ ] Task 7: Camera Lifecycle Management
  - [ ] Implement proper camera start/stop logic
  - [ ] Handle app backgrounding and foregrounding
  - [ ] Add camera pause/resume functionality
  - [ ] Implement proper resource cleanup
  - [ ] Test lifecycle on both platforms

- [ ] Task 8: Error Handling & Recovery
  - [ ] Implement comprehensive camera error handling
  - [ ] Add error recovery mechanisms
  - [ ] Handle device-specific camera issues
  - [ ] Implement graceful fallback options
  - [ ] Test error scenarios and recovery

### **Phase 5: Integration & Testing (ACs: 9, 10)**

- [ ] Task 9: Debug Integration
  - [ ] Add camera status logging to debug view
  - [ ] Implement camera initialization progress tracking
  - [ ] Add camera metrics to debug display
  - [ ] Test debug information accuracy
  - [ ] Verify logging functionality

- [ ] Task 10: Final Integration & Validation
  - [ ] Integrate camera preview with main check-in screen
  - [ ] Test complete camera initialization flow
  - [ ] Validate performance and quality standards
  - [ ] Ensure seamless integration with BLoC state
  - [ ] Prepare for WebSocket integration (next story)

## Dev Technical Guidance

### Camera Integration Architecture
```dart
// Camera controller and state management structure
class CameraService {
  CameraController? _controller;
  bool _isInitialized = false;
  
  Future<void> initialize();
  Future<void> dispose();
  CameraImage? captureFrame();
  
  // State streams
  Stream<CameraStatus> get statusStream;
  Stream<CameraImage> get frameStream;
}
```

### BLoC Integration Pattern
```dart
// Extended CheckInState for camera
@freezed
class CheckInState with _$CheckInState {
  const factory CheckInState({
    @Default(CameraStatus.initial) CameraStatus cameraStatus,
    @Default(PermissionStatus.initial) PermissionStatus permissionStatus,
    @Default(ConnectionStatus.disconnected) ConnectionStatus connectionStatus,
    @Default(StreamingStatus.idle) StreamingStatus streamingStatus,
    @Default(false) bool isLoading,
    String? errorMessage,
    CameraController? cameraController,
    // Toast-related state
    @Default(ToastStatus.none) ToastStatus toastStatus,
    String? toastMessage,
  }) = _CheckInState;
}

enum CameraStatus { 
  initial, 
  permissionRequesting, 
  permissionDenied, 
  initializing, 
  ready, 
  streaming,
  paused,
  error 
}

enum PermissionStatus { initial, granted, denied, permanentlyDenied }
```

### Camera Events Extension
```dart
// Extended CheckInEvent for camera
@freezed
class CheckInEvent with _$CheckInEvent {
  // Existing events...
  
  // Camera permission events
  const factory CheckInEvent.cameraPermissionRequested() = CameraPermissionRequested;
  const factory CheckInEvent.cameraPermissionGranted() = CameraPermissionGranted;
  const factory CheckInEvent.cameraPermissionDenied() = CameraPermissionDenied;
  
  // Camera lifecycle events
  const factory CheckInEvent.cameraInitRequested() = CameraInitRequested;
  const factory CheckInEvent.cameraInitialized() = CameraInitialized;
  const factory CheckInEvent.cameraStarted() = CameraStarted;
  const factory CheckInEvent.cameraPaused() = CameraPaused;
  const factory CheckInEvent.cameraResumed() = CameraResumed;
  const factory CheckInEvent.cameraStopped() = CameraStopped;
  
  // Camera error events
  const factory CheckInEvent.cameraError(String error) = CameraError;
}
```

### Camera Preview Widget Implementation
```dart
// Camera preview widget structure
class CameraPreviewWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CheckInBloc, CheckInState>(
      builder: (context, state) {
        switch (state.cameraStatus) {
          case CameraStatus.initial:
            return const CircularProgressIndicator();
          case CameraStatus.permissionDenied:
            return const PermissionDeniedWidget();
          case CameraStatus.ready:
          case CameraStatus.streaming:
            return AspectRatio(
              aspectRatio: state.cameraController!.value.aspectRatio,
              child: CameraPreview(state.cameraController!),
            );
          case CameraStatus.error:
            return CameraErrorWidget(error: state.errorMessage);
          default:
            return const CameraLoadingWidget();
        }
      },
    );
  }
}
```

### Permission Handling Implementation
```dart
// Permission handling logic
class CameraPermissionHandler {
  static Future<PermissionStatus> requestPermission() async {
    final status = await Permission.camera.request();
    
    switch (status) {
      case PermissionStatus.granted:
        return PermissionStatus.granted;
      case PermissionStatus.denied:
        return PermissionStatus.denied;
      case PermissionStatus.permanentlyDenied:
        return PermissionStatus.permanentlyDenied;
      default:
        return PermissionStatus.denied;
    }
  }
  
  static Future<void> openAppSettings() async {
    await openAppSettings();
  }
}
```

### Camera Configuration Specifications
- **Resolution**: 640x480 (optimized for recognition and performance)
- **Format**: YUV420 (standard format for mobile cameras)
- **Frame Rate**: 30 FPS (smooth preview)
- **Quality**: High enough for facial recognition (configurable)
- **Orientation**: Portrait mode primary

### Error Handling Strategy
- **Permission Denied**: Show guidance to user with settings link
- **Camera Unavailable**: Display friendly error message with retry option
- **Initialization Failed**: Implement retry logic with exponential backoff
- **Device Specific Issues**: Handle known device compatibility issues
- **Resource Conflicts**: Handle camera resource conflicts gracefully

### Performance Considerations
- **Memory Management**: Proper disposal of camera controller
- **Resource Cleanup**: Clean up resources on app pause/dispose
- **Frame Processing**: Optimize frame capture for performance
- **Battery Usage**: Monitor and optimize battery consumption
- **Background Handling**: Proper camera pause when app goes to background

### **TDD-Specific Requirements**
- **Test Coverage**: Minimum 80% for camera service, permission handler, and BLoC integration
- **Test Quality**: Camera tests should handle device-specific scenarios and mock hardware properly
- **Test Organization**: Separate unit tests for service logic, widget tests for preview components
- **Mock Strategy**: Use fake camera controller and mock permission handler for reliable testing

### **Camera TDD Testing Patterns**
```dart
// Example TDD approach for camera testing
group('CameraService', () {
  late CameraService cameraService;
  late MockCameraController mockController;
  late MockPermissionHandler mockPermissionHandler;

  setUp(() {
    mockController = MockCameraController();
    mockPermissionHandler = MockPermissionHandler();
    cameraService = CameraService(
      controller: mockController,
      permissionHandler: mockPermissionHandler,
    );
  });

  // RED: Write failing test first
  test('should initialize camera when permission granted', () async {
    // arrange
    when(() => mockPermissionHandler.requestCameraPermission())
        .thenAnswer((_) async => PermissionStatus.granted);
    when(() => mockController.initialize())
        .thenAnswer((_) async => {});

    // act
    final result = await cameraService.initialize();

    // assert
    expect(result, isTrue);
    verify(() => mockController.initialize()).called(1);
  });

  // Test camera lifecycle
  test('should pause camera when app goes to background', () async {
    // arrange
    await cameraService.initialize();
    
    // act
    await cameraService.pause();
    
    // assert
    expect(cameraService.isActive, isFalse);
  });
});

// Widget testing for camera preview
group('CameraPreviewWidget', () {
  testWidgets('should display loading when camera is initializing', (tester) async {
    // arrange
    const state = CheckInState(cameraStatus: CameraStatus.initializing);
    
    // act
    await tester.pumpWidget(
      MaterialApp(
        home: BlocProvider(
          create: (_) => MockCheckInBloc()..emit(state),
          child: CameraPreviewWidget(),
        ),
      ),
    );
    
    // assert
    expect(find.byType(CircularProgressIndicator), findsOneWidget);
  });
});
```

### **Quality Standards**
- **Camera Integration**: Proper camera lifecycle management and resource cleanup
- **Permission Handling**: Comprehensive permission scenarios with user guidance
- **Error Handling**: Graceful handling of camera-specific errors and recovery
- **Performance**: Optimized for battery usage and memory management
- **Testing**: Complete TDD test coverage with hardware mocking

## Definition of Done Checklist

### **TDD-Specific DoD**
- [ ] **Test-First Development**: All camera features developed using TDD RED-GREEN-REFACTOR cycle
- [ ] **Test Coverage**: 80%+ coverage achieved for camera service, permission handling, and BLoC integration
- [ ] **Test Quality**: Camera tests handle device variations and hardware mocking appropriately
- [ ] **Test Documentation**: Camera testing strategy and device-specific scenarios documented
- [ ] **Mock Strategy**: Camera controller and permission handler properly mocked for reliable testing

### **Standard DoD**
- [ ] **Code Review**: Reviewed by team member with camera integration and TDD experience
- [ ] **Integration**: Camera seamlessly integrated with BLoC state management
- [ ] **Documentation**: Camera integration patterns and troubleshooting documented
- [ ] **Device Testing**: Tested on both iOS and Android across multiple device types
- [ ] **Performance**: Camera operations optimized for memory and battery efficiency

### **Story-Specific Requirements**
- [ ] **Permission Flow**: Complete permission handling with user guidance for all scenarios
- [ ] **Camera Preview**: Live preview displays correctly with proper aspect ratio and quality
- [ ] **Lifecycle Management**: Camera properly handles app backgrounding/foregrounding
- [ ] **Error Handling**: All camera error scenarios handled gracefully with recovery options
- [ ] **BLoC Integration**: Camera states and events fully integrated with CheckInBloc
- [ ] **Debug Logging**: Camera status and metrics visible in debug view
- [ ] **WebSocket Ready**: Camera service prepared for frame streaming integration

### **Testing Strategy**
- **Permission Tests**: Test all permission scenarios (granted, denied, permanently denied)
- **Device Tests**: Test on multiple device types and OS versions
- **Lifecycle Tests**: Test app backgrounding/foregrounding scenarios
- **Error Tests**: Test various camera error conditions and recovery
- **Integration Tests**: Test complete camera-BLoC workflow
- **Performance Tests**: Monitor memory usage and battery consumption

### **Integration Points**
- **BLoC State**: Camera status fully integrated into CheckInState
- **Debug View**: Camera status and metrics displayed in debug view
- **WebSocket Service**: Camera service ready for frame streaming integration (Story 2.2)
- **Permission System**: Permission handling ready for production use
- **UI Components**: Camera preview integrated into check-in screen
- **Error Handling**: Camera errors handled through unified error system

### Quality Standards
- **Permission UX**: Clear permission request flow
- **Error Messages**: User-friendly error communication
- **Performance**: Smooth camera preview without lag
- **Resource Management**: No memory leaks or resource conflicts
- **Cross-Platform**: Consistent behavior on Android and iOS

## Story Progress Notes

### Agent Model Used: `<To be filled by implementing agent>`

### Completion Notes List

*{Implementation notes will be filled by the implementing agent}*

### Change Log 