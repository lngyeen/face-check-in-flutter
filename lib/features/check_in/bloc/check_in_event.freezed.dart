// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'check_in_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$SeparatedSequentialCheckInEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(dynamic data) webSocketMessageReceived,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(dynamic data)? webSocketMessageReceived,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(dynamic data)? webSocketMessageReceived,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(WebSocketMessageReceived value)
    webSocketMessageReceived,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initialize value)? initialize,
    TResult? Function(WebSocketMessageReceived value)? webSocketMessageReceived,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(WebSocketMessageReceived value)? webSocketMessageReceived,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SeparatedSequentialCheckInEventCopyWith<$Res> {
  factory $SeparatedSequentialCheckInEventCopyWith(
    SeparatedSequentialCheckInEvent value,
    $Res Function(SeparatedSequentialCheckInEvent) then,
  ) =
      _$SeparatedSequentialCheckInEventCopyWithImpl<
        $Res,
        SeparatedSequentialCheckInEvent
      >;
}

/// @nodoc
class _$SeparatedSequentialCheckInEventCopyWithImpl<
  $Res,
  $Val extends SeparatedSequentialCheckInEvent
>
    implements $SeparatedSequentialCheckInEventCopyWith<$Res> {
  _$SeparatedSequentialCheckInEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SeparatedSequentialCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitializeImplCopyWith<$Res> {
  factory _$$InitializeImplCopyWith(
    _$InitializeImpl value,
    $Res Function(_$InitializeImpl) then,
  ) = __$$InitializeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitializeImplCopyWithImpl<$Res>
    extends
        _$SeparatedSequentialCheckInEventCopyWithImpl<$Res, _$InitializeImpl>
    implements _$$InitializeImplCopyWith<$Res> {
  __$$InitializeImplCopyWithImpl(
    _$InitializeImpl _value,
    $Res Function(_$InitializeImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SeparatedSequentialCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitializeImpl implements Initialize {
  const _$InitializeImpl();

  @override
  String toString() {
    return 'SeparatedSequentialCheckInEvent.initialize()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitializeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(dynamic data) webSocketMessageReceived,
  }) {
    return initialize();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(dynamic data)? webSocketMessageReceived,
  }) {
    return initialize?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(dynamic data)? webSocketMessageReceived,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(WebSocketMessageReceived value)
    webSocketMessageReceived,
  }) {
    return initialize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initialize value)? initialize,
    TResult? Function(WebSocketMessageReceived value)? webSocketMessageReceived,
  }) {
    return initialize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(WebSocketMessageReceived value)? webSocketMessageReceived,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize(this);
    }
    return orElse();
  }
}

abstract class Initialize implements SeparatedSequentialCheckInEvent {
  const factory Initialize() = _$InitializeImpl;
}

/// @nodoc
abstract class _$$WebSocketMessageReceivedImplCopyWith<$Res> {
  factory _$$WebSocketMessageReceivedImplCopyWith(
    _$WebSocketMessageReceivedImpl value,
    $Res Function(_$WebSocketMessageReceivedImpl) then,
  ) = __$$WebSocketMessageReceivedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic data});
}

/// @nodoc
class __$$WebSocketMessageReceivedImplCopyWithImpl<$Res>
    extends
        _$SeparatedSequentialCheckInEventCopyWithImpl<
          $Res,
          _$WebSocketMessageReceivedImpl
        >
    implements _$$WebSocketMessageReceivedImplCopyWith<$Res> {
  __$$WebSocketMessageReceivedImplCopyWithImpl(
    _$WebSocketMessageReceivedImpl _value,
    $Res Function(_$WebSocketMessageReceivedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SeparatedSequentialCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? data = freezed}) {
    return _then(
      _$WebSocketMessageReceivedImpl(
        data:
            freezed == data
                ? _value.data
                : data // ignore: cast_nullable_to_non_nullable
                    as dynamic,
      ),
    );
  }
}

/// @nodoc

class _$WebSocketMessageReceivedImpl implements WebSocketMessageReceived {
  const _$WebSocketMessageReceivedImpl({required this.data});

  @override
  final dynamic data;

  @override
  String toString() {
    return 'SeparatedSequentialCheckInEvent.webSocketMessageReceived(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WebSocketMessageReceivedImpl &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  /// Create a copy of SeparatedSequentialCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WebSocketMessageReceivedImplCopyWith<_$WebSocketMessageReceivedImpl>
  get copyWith => __$$WebSocketMessageReceivedImplCopyWithImpl<
    _$WebSocketMessageReceivedImpl
  >(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialize,
    required TResult Function(dynamic data) webSocketMessageReceived,
  }) {
    return webSocketMessageReceived(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialize,
    TResult? Function(dynamic data)? webSocketMessageReceived,
  }) {
    return webSocketMessageReceived?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialize,
    TResult Function(dynamic data)? webSocketMessageReceived,
    required TResult orElse(),
  }) {
    if (webSocketMessageReceived != null) {
      return webSocketMessageReceived(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initialize value) initialize,
    required TResult Function(WebSocketMessageReceived value)
    webSocketMessageReceived,
  }) {
    return webSocketMessageReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initialize value)? initialize,
    TResult? Function(WebSocketMessageReceived value)? webSocketMessageReceived,
  }) {
    return webSocketMessageReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initialize value)? initialize,
    TResult Function(WebSocketMessageReceived value)? webSocketMessageReceived,
    required TResult orElse(),
  }) {
    if (webSocketMessageReceived != null) {
      return webSocketMessageReceived(this);
    }
    return orElse();
  }
}

abstract class WebSocketMessageReceived
    implements SeparatedSequentialCheckInEvent {
  const factory WebSocketMessageReceived({required final dynamic data}) =
      _$WebSocketMessageReceivedImpl;

  dynamic get data;

  /// Create a copy of SeparatedSequentialCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WebSocketMessageReceivedImplCopyWith<_$WebSocketMessageReceivedImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BucketRestartableCheckInEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startCamera,
    required TResult Function() stopCamera,
    required TResult Function() startImageStream,
    required TResult Function() stopImageStream,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startCamera,
    TResult? Function()? stopCamera,
    TResult? Function()? startImageStream,
    TResult? Function()? stopImageStream,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startCamera,
    TResult Function()? stopCamera,
    TResult Function()? startImageStream,
    TResult Function()? stopImageStream,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartCamera value) startCamera,
    required TResult Function(StopCamera value) stopCamera,
    required TResult Function(StartImageStream value) startImageStream,
    required TResult Function(StopImageStream value) stopImageStream,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartCamera value)? startCamera,
    TResult? Function(StopCamera value)? stopCamera,
    TResult? Function(StartImageStream value)? startImageStream,
    TResult? Function(StopImageStream value)? stopImageStream,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartCamera value)? startCamera,
    TResult Function(StopCamera value)? stopCamera,
    TResult Function(StartImageStream value)? startImageStream,
    TResult Function(StopImageStream value)? stopImageStream,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BucketRestartableCheckInEventCopyWith<$Res> {
  factory $BucketRestartableCheckInEventCopyWith(
    BucketRestartableCheckInEvent value,
    $Res Function(BucketRestartableCheckInEvent) then,
  ) =
      _$BucketRestartableCheckInEventCopyWithImpl<
        $Res,
        BucketRestartableCheckInEvent
      >;
}

/// @nodoc
class _$BucketRestartableCheckInEventCopyWithImpl<
  $Res,
  $Val extends BucketRestartableCheckInEvent
>
    implements $BucketRestartableCheckInEventCopyWith<$Res> {
  _$BucketRestartableCheckInEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BucketRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartCameraImplCopyWith<$Res> {
  factory _$$StartCameraImplCopyWith(
    _$StartCameraImpl value,
    $Res Function(_$StartCameraImpl) then,
  ) = __$$StartCameraImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartCameraImplCopyWithImpl<$Res>
    extends _$BucketRestartableCheckInEventCopyWithImpl<$Res, _$StartCameraImpl>
    implements _$$StartCameraImplCopyWith<$Res> {
  __$$StartCameraImplCopyWithImpl(
    _$StartCameraImpl _value,
    $Res Function(_$StartCameraImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of BucketRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartCameraImpl implements StartCamera {
  const _$StartCameraImpl();

  @override
  String toString() {
    return 'BucketRestartableCheckInEvent.startCamera()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartCameraImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startCamera,
    required TResult Function() stopCamera,
    required TResult Function() startImageStream,
    required TResult Function() stopImageStream,
  }) {
    return startCamera();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startCamera,
    TResult? Function()? stopCamera,
    TResult? Function()? startImageStream,
    TResult? Function()? stopImageStream,
  }) {
    return startCamera?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startCamera,
    TResult Function()? stopCamera,
    TResult Function()? startImageStream,
    TResult Function()? stopImageStream,
    required TResult orElse(),
  }) {
    if (startCamera != null) {
      return startCamera();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartCamera value) startCamera,
    required TResult Function(StopCamera value) stopCamera,
    required TResult Function(StartImageStream value) startImageStream,
    required TResult Function(StopImageStream value) stopImageStream,
  }) {
    return startCamera(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartCamera value)? startCamera,
    TResult? Function(StopCamera value)? stopCamera,
    TResult? Function(StartImageStream value)? startImageStream,
    TResult? Function(StopImageStream value)? stopImageStream,
  }) {
    return startCamera?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartCamera value)? startCamera,
    TResult Function(StopCamera value)? stopCamera,
    TResult Function(StartImageStream value)? startImageStream,
    TResult Function(StopImageStream value)? stopImageStream,
    required TResult orElse(),
  }) {
    if (startCamera != null) {
      return startCamera(this);
    }
    return orElse();
  }
}

abstract class StartCamera implements BucketRestartableCheckInEvent {
  const factory StartCamera() = _$StartCameraImpl;
}

/// @nodoc
abstract class _$$StopCameraImplCopyWith<$Res> {
  factory _$$StopCameraImplCopyWith(
    _$StopCameraImpl value,
    $Res Function(_$StopCameraImpl) then,
  ) = __$$StopCameraImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StopCameraImplCopyWithImpl<$Res>
    extends _$BucketRestartableCheckInEventCopyWithImpl<$Res, _$StopCameraImpl>
    implements _$$StopCameraImplCopyWith<$Res> {
  __$$StopCameraImplCopyWithImpl(
    _$StopCameraImpl _value,
    $Res Function(_$StopCameraImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of BucketRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StopCameraImpl implements StopCamera {
  const _$StopCameraImpl();

  @override
  String toString() {
    return 'BucketRestartableCheckInEvent.stopCamera()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StopCameraImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startCamera,
    required TResult Function() stopCamera,
    required TResult Function() startImageStream,
    required TResult Function() stopImageStream,
  }) {
    return stopCamera();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startCamera,
    TResult? Function()? stopCamera,
    TResult? Function()? startImageStream,
    TResult? Function()? stopImageStream,
  }) {
    return stopCamera?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startCamera,
    TResult Function()? stopCamera,
    TResult Function()? startImageStream,
    TResult Function()? stopImageStream,
    required TResult orElse(),
  }) {
    if (stopCamera != null) {
      return stopCamera();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartCamera value) startCamera,
    required TResult Function(StopCamera value) stopCamera,
    required TResult Function(StartImageStream value) startImageStream,
    required TResult Function(StopImageStream value) stopImageStream,
  }) {
    return stopCamera(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartCamera value)? startCamera,
    TResult? Function(StopCamera value)? stopCamera,
    TResult? Function(StartImageStream value)? startImageStream,
    TResult? Function(StopImageStream value)? stopImageStream,
  }) {
    return stopCamera?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartCamera value)? startCamera,
    TResult Function(StopCamera value)? stopCamera,
    TResult Function(StartImageStream value)? startImageStream,
    TResult Function(StopImageStream value)? stopImageStream,
    required TResult orElse(),
  }) {
    if (stopCamera != null) {
      return stopCamera(this);
    }
    return orElse();
  }
}

abstract class StopCamera implements BucketRestartableCheckInEvent {
  const factory StopCamera() = _$StopCameraImpl;
}

/// @nodoc
abstract class _$$StartImageStreamImplCopyWith<$Res> {
  factory _$$StartImageStreamImplCopyWith(
    _$StartImageStreamImpl value,
    $Res Function(_$StartImageStreamImpl) then,
  ) = __$$StartImageStreamImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartImageStreamImplCopyWithImpl<$Res>
    extends
        _$BucketRestartableCheckInEventCopyWithImpl<
          $Res,
          _$StartImageStreamImpl
        >
    implements _$$StartImageStreamImplCopyWith<$Res> {
  __$$StartImageStreamImplCopyWithImpl(
    _$StartImageStreamImpl _value,
    $Res Function(_$StartImageStreamImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of BucketRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartImageStreamImpl implements StartImageStream {
  const _$StartImageStreamImpl();

  @override
  String toString() {
    return 'BucketRestartableCheckInEvent.startImageStream()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartImageStreamImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startCamera,
    required TResult Function() stopCamera,
    required TResult Function() startImageStream,
    required TResult Function() stopImageStream,
  }) {
    return startImageStream();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startCamera,
    TResult? Function()? stopCamera,
    TResult? Function()? startImageStream,
    TResult? Function()? stopImageStream,
  }) {
    return startImageStream?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startCamera,
    TResult Function()? stopCamera,
    TResult Function()? startImageStream,
    TResult Function()? stopImageStream,
    required TResult orElse(),
  }) {
    if (startImageStream != null) {
      return startImageStream();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartCamera value) startCamera,
    required TResult Function(StopCamera value) stopCamera,
    required TResult Function(StartImageStream value) startImageStream,
    required TResult Function(StopImageStream value) stopImageStream,
  }) {
    return startImageStream(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartCamera value)? startCamera,
    TResult? Function(StopCamera value)? stopCamera,
    TResult? Function(StartImageStream value)? startImageStream,
    TResult? Function(StopImageStream value)? stopImageStream,
  }) {
    return startImageStream?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartCamera value)? startCamera,
    TResult Function(StopCamera value)? stopCamera,
    TResult Function(StartImageStream value)? startImageStream,
    TResult Function(StopImageStream value)? stopImageStream,
    required TResult orElse(),
  }) {
    if (startImageStream != null) {
      return startImageStream(this);
    }
    return orElse();
  }
}

abstract class StartImageStream implements BucketRestartableCheckInEvent {
  const factory StartImageStream() = _$StartImageStreamImpl;
}

/// @nodoc
abstract class _$$StopImageStreamImplCopyWith<$Res> {
  factory _$$StopImageStreamImplCopyWith(
    _$StopImageStreamImpl value,
    $Res Function(_$StopImageStreamImpl) then,
  ) = __$$StopImageStreamImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StopImageStreamImplCopyWithImpl<$Res>
    extends
        _$BucketRestartableCheckInEventCopyWithImpl<$Res, _$StopImageStreamImpl>
    implements _$$StopImageStreamImplCopyWith<$Res> {
  __$$StopImageStreamImplCopyWithImpl(
    _$StopImageStreamImpl _value,
    $Res Function(_$StopImageStreamImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of BucketRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StopImageStreamImpl implements StopImageStream {
  const _$StopImageStreamImpl();

  @override
  String toString() {
    return 'BucketRestartableCheckInEvent.stopImageStream()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StopImageStreamImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startCamera,
    required TResult Function() stopCamera,
    required TResult Function() startImageStream,
    required TResult Function() stopImageStream,
  }) {
    return stopImageStream();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startCamera,
    TResult? Function()? stopCamera,
    TResult? Function()? startImageStream,
    TResult? Function()? stopImageStream,
  }) {
    return stopImageStream?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startCamera,
    TResult Function()? stopCamera,
    TResult Function()? startImageStream,
    TResult Function()? stopImageStream,
    required TResult orElse(),
  }) {
    if (stopImageStream != null) {
      return stopImageStream();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartCamera value) startCamera,
    required TResult Function(StopCamera value) stopCamera,
    required TResult Function(StartImageStream value) startImageStream,
    required TResult Function(StopImageStream value) stopImageStream,
  }) {
    return stopImageStream(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartCamera value)? startCamera,
    TResult? Function(StopCamera value)? stopCamera,
    TResult? Function(StartImageStream value)? startImageStream,
    TResult? Function(StopImageStream value)? stopImageStream,
  }) {
    return stopImageStream?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartCamera value)? startCamera,
    TResult Function(StopCamera value)? stopCamera,
    TResult Function(StartImageStream value)? startImageStream,
    TResult Function(StopImageStream value)? stopImageStream,
    required TResult orElse(),
  }) {
    if (stopImageStream != null) {
      return stopImageStream(this);
    }
    return orElse();
  }
}

abstract class StopImageStream implements BucketRestartableCheckInEvent {
  const factory StopImageStream() = _$StopImageStreamImpl;
}

/// @nodoc
mixin _$SeparatedRestartableCheckInEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ConnectionState connectionState)
    connectionStateChanged,
    required TResult Function(CameraStatus status) cameraStatusChanged,
    required TResult Function(CameraController? controller)
    cameraControllerChanged,
    required TResult Function(StreamingStatus status) streamingStatusChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ConnectionState connectionState)? connectionStateChanged,
    TResult? Function(CameraStatus status)? cameraStatusChanged,
    TResult? Function(CameraController? controller)? cameraControllerChanged,
    TResult? Function(StreamingStatus status)? streamingStatusChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ConnectionState connectionState)? connectionStateChanged,
    TResult Function(CameraStatus status)? cameraStatusChanged,
    TResult Function(CameraController? controller)? cameraControllerChanged,
    TResult Function(StreamingStatus status)? streamingStatusChanged,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionStateChanged value)
    connectionStateChanged,
    required TResult Function(CameraStatusChanged value) cameraStatusChanged,
    required TResult Function(CameraControllerChanged value)
    cameraControllerChanged,
    required TResult Function(StreamingStatusChanged value)
    streamingStatusChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult? Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult? Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult? Function(StreamingStatusChanged value)? streamingStatusChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult Function(StreamingStatusChanged value)? streamingStatusChanged,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SeparatedRestartableCheckInEventCopyWith<$Res> {
  factory $SeparatedRestartableCheckInEventCopyWith(
    SeparatedRestartableCheckInEvent value,
    $Res Function(SeparatedRestartableCheckInEvent) then,
  ) =
      _$SeparatedRestartableCheckInEventCopyWithImpl<
        $Res,
        SeparatedRestartableCheckInEvent
      >;
}

/// @nodoc
class _$SeparatedRestartableCheckInEventCopyWithImpl<
  $Res,
  $Val extends SeparatedRestartableCheckInEvent
>
    implements $SeparatedRestartableCheckInEventCopyWith<$Res> {
  _$SeparatedRestartableCheckInEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ConnectionStateChangedImplCopyWith<$Res> {
  factory _$$ConnectionStateChangedImplCopyWith(
    _$ConnectionStateChangedImpl value,
    $Res Function(_$ConnectionStateChangedImpl) then,
  ) = __$$ConnectionStateChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ConnectionState connectionState});

  $ConnectionStateCopyWith<$Res> get connectionState;
}

/// @nodoc
class __$$ConnectionStateChangedImplCopyWithImpl<$Res>
    extends
        _$SeparatedRestartableCheckInEventCopyWithImpl<
          $Res,
          _$ConnectionStateChangedImpl
        >
    implements _$$ConnectionStateChangedImplCopyWith<$Res> {
  __$$ConnectionStateChangedImplCopyWithImpl(
    _$ConnectionStateChangedImpl _value,
    $Res Function(_$ConnectionStateChangedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? connectionState = null}) {
    return _then(
      _$ConnectionStateChangedImpl(
        connectionState:
            null == connectionState
                ? _value.connectionState
                : connectionState // ignore: cast_nullable_to_non_nullable
                    as ConnectionState,
      ),
    );
  }

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ConnectionStateCopyWith<$Res> get connectionState {
    return $ConnectionStateCopyWith<$Res>(_value.connectionState, (value) {
      return _then(_value.copyWith(connectionState: value));
    });
  }
}

/// @nodoc

class _$ConnectionStateChangedImpl implements ConnectionStateChanged {
  const _$ConnectionStateChangedImpl({required this.connectionState});

  @override
  final ConnectionState connectionState;

  @override
  String toString() {
    return 'SeparatedRestartableCheckInEvent.connectionStateChanged(connectionState: $connectionState)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionStateChangedImpl &&
            (identical(other.connectionState, connectionState) ||
                other.connectionState == connectionState));
  }

  @override
  int get hashCode => Object.hash(runtimeType, connectionState);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConnectionStateChangedImplCopyWith<_$ConnectionStateChangedImpl>
  get copyWith =>
      __$$ConnectionStateChangedImplCopyWithImpl<_$ConnectionStateChangedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ConnectionState connectionState)
    connectionStateChanged,
    required TResult Function(CameraStatus status) cameraStatusChanged,
    required TResult Function(CameraController? controller)
    cameraControllerChanged,
    required TResult Function(StreamingStatus status) streamingStatusChanged,
  }) {
    return connectionStateChanged(connectionState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ConnectionState connectionState)? connectionStateChanged,
    TResult? Function(CameraStatus status)? cameraStatusChanged,
    TResult? Function(CameraController? controller)? cameraControllerChanged,
    TResult? Function(StreamingStatus status)? streamingStatusChanged,
  }) {
    return connectionStateChanged?.call(connectionState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ConnectionState connectionState)? connectionStateChanged,
    TResult Function(CameraStatus status)? cameraStatusChanged,
    TResult Function(CameraController? controller)? cameraControllerChanged,
    TResult Function(StreamingStatus status)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (connectionStateChanged != null) {
      return connectionStateChanged(connectionState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionStateChanged value)
    connectionStateChanged,
    required TResult Function(CameraStatusChanged value) cameraStatusChanged,
    required TResult Function(CameraControllerChanged value)
    cameraControllerChanged,
    required TResult Function(StreamingStatusChanged value)
    streamingStatusChanged,
  }) {
    return connectionStateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult? Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult? Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult? Function(StreamingStatusChanged value)? streamingStatusChanged,
  }) {
    return connectionStateChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult Function(StreamingStatusChanged value)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (connectionStateChanged != null) {
      return connectionStateChanged(this);
    }
    return orElse();
  }
}

abstract class ConnectionStateChanged
    implements SeparatedRestartableCheckInEvent {
  const factory ConnectionStateChanged({
    required final ConnectionState connectionState,
  }) = _$ConnectionStateChangedImpl;

  ConnectionState get connectionState;

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConnectionStateChangedImplCopyWith<_$ConnectionStateChangedImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CameraStatusChangedImplCopyWith<$Res> {
  factory _$$CameraStatusChangedImplCopyWith(
    _$CameraStatusChangedImpl value,
    $Res Function(_$CameraStatusChangedImpl) then,
  ) = __$$CameraStatusChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CameraStatus status});
}

/// @nodoc
class __$$CameraStatusChangedImplCopyWithImpl<$Res>
    extends
        _$SeparatedRestartableCheckInEventCopyWithImpl<
          $Res,
          _$CameraStatusChangedImpl
        >
    implements _$$CameraStatusChangedImplCopyWith<$Res> {
  __$$CameraStatusChangedImplCopyWithImpl(
    _$CameraStatusChangedImpl _value,
    $Res Function(_$CameraStatusChangedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? status = null}) {
    return _then(
      _$CameraStatusChangedImpl(
        status:
            null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                    as CameraStatus,
      ),
    );
  }
}

/// @nodoc

class _$CameraStatusChangedImpl implements CameraStatusChanged {
  const _$CameraStatusChangedImpl({required this.status});

  @override
  final CameraStatus status;

  @override
  String toString() {
    return 'SeparatedRestartableCheckInEvent.cameraStatusChanged(status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CameraStatusChangedImpl &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CameraStatusChangedImplCopyWith<_$CameraStatusChangedImpl> get copyWith =>
      __$$CameraStatusChangedImplCopyWithImpl<_$CameraStatusChangedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ConnectionState connectionState)
    connectionStateChanged,
    required TResult Function(CameraStatus status) cameraStatusChanged,
    required TResult Function(CameraController? controller)
    cameraControllerChanged,
    required TResult Function(StreamingStatus status) streamingStatusChanged,
  }) {
    return cameraStatusChanged(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ConnectionState connectionState)? connectionStateChanged,
    TResult? Function(CameraStatus status)? cameraStatusChanged,
    TResult? Function(CameraController? controller)? cameraControllerChanged,
    TResult? Function(StreamingStatus status)? streamingStatusChanged,
  }) {
    return cameraStatusChanged?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ConnectionState connectionState)? connectionStateChanged,
    TResult Function(CameraStatus status)? cameraStatusChanged,
    TResult Function(CameraController? controller)? cameraControllerChanged,
    TResult Function(StreamingStatus status)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (cameraStatusChanged != null) {
      return cameraStatusChanged(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionStateChanged value)
    connectionStateChanged,
    required TResult Function(CameraStatusChanged value) cameraStatusChanged,
    required TResult Function(CameraControllerChanged value)
    cameraControllerChanged,
    required TResult Function(StreamingStatusChanged value)
    streamingStatusChanged,
  }) {
    return cameraStatusChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult? Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult? Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult? Function(StreamingStatusChanged value)? streamingStatusChanged,
  }) {
    return cameraStatusChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult Function(StreamingStatusChanged value)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (cameraStatusChanged != null) {
      return cameraStatusChanged(this);
    }
    return orElse();
  }
}

abstract class CameraStatusChanged implements SeparatedRestartableCheckInEvent {
  const factory CameraStatusChanged({required final CameraStatus status}) =
      _$CameraStatusChangedImpl;

  CameraStatus get status;

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CameraStatusChangedImplCopyWith<_$CameraStatusChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CameraControllerChangedImplCopyWith<$Res> {
  factory _$$CameraControllerChangedImplCopyWith(
    _$CameraControllerChangedImpl value,
    $Res Function(_$CameraControllerChangedImpl) then,
  ) = __$$CameraControllerChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CameraController? controller});
}

/// @nodoc
class __$$CameraControllerChangedImplCopyWithImpl<$Res>
    extends
        _$SeparatedRestartableCheckInEventCopyWithImpl<
          $Res,
          _$CameraControllerChangedImpl
        >
    implements _$$CameraControllerChangedImplCopyWith<$Res> {
  __$$CameraControllerChangedImplCopyWithImpl(
    _$CameraControllerChangedImpl _value,
    $Res Function(_$CameraControllerChangedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? controller = freezed}) {
    return _then(
      _$CameraControllerChangedImpl(
        controller:
            freezed == controller
                ? _value.controller
                : controller // ignore: cast_nullable_to_non_nullable
                    as CameraController?,
      ),
    );
  }
}

/// @nodoc

class _$CameraControllerChangedImpl implements CameraControllerChanged {
  const _$CameraControllerChangedImpl({this.controller});

  @override
  final CameraController? controller;

  @override
  String toString() {
    return 'SeparatedRestartableCheckInEvent.cameraControllerChanged(controller: $controller)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CameraControllerChangedImpl &&
            (identical(other.controller, controller) ||
                other.controller == controller));
  }

  @override
  int get hashCode => Object.hash(runtimeType, controller);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CameraControllerChangedImplCopyWith<_$CameraControllerChangedImpl>
  get copyWith => __$$CameraControllerChangedImplCopyWithImpl<
    _$CameraControllerChangedImpl
  >(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ConnectionState connectionState)
    connectionStateChanged,
    required TResult Function(CameraStatus status) cameraStatusChanged,
    required TResult Function(CameraController? controller)
    cameraControllerChanged,
    required TResult Function(StreamingStatus status) streamingStatusChanged,
  }) {
    return cameraControllerChanged(controller);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ConnectionState connectionState)? connectionStateChanged,
    TResult? Function(CameraStatus status)? cameraStatusChanged,
    TResult? Function(CameraController? controller)? cameraControllerChanged,
    TResult? Function(StreamingStatus status)? streamingStatusChanged,
  }) {
    return cameraControllerChanged?.call(controller);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ConnectionState connectionState)? connectionStateChanged,
    TResult Function(CameraStatus status)? cameraStatusChanged,
    TResult Function(CameraController? controller)? cameraControllerChanged,
    TResult Function(StreamingStatus status)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (cameraControllerChanged != null) {
      return cameraControllerChanged(controller);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionStateChanged value)
    connectionStateChanged,
    required TResult Function(CameraStatusChanged value) cameraStatusChanged,
    required TResult Function(CameraControllerChanged value)
    cameraControllerChanged,
    required TResult Function(StreamingStatusChanged value)
    streamingStatusChanged,
  }) {
    return cameraControllerChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult? Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult? Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult? Function(StreamingStatusChanged value)? streamingStatusChanged,
  }) {
    return cameraControllerChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult Function(StreamingStatusChanged value)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (cameraControllerChanged != null) {
      return cameraControllerChanged(this);
    }
    return orElse();
  }
}

abstract class CameraControllerChanged
    implements SeparatedRestartableCheckInEvent {
  const factory CameraControllerChanged({final CameraController? controller}) =
      _$CameraControllerChangedImpl;

  CameraController? get controller;

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CameraControllerChangedImplCopyWith<_$CameraControllerChangedImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StreamingStatusChangedImplCopyWith<$Res> {
  factory _$$StreamingStatusChangedImplCopyWith(
    _$StreamingStatusChangedImpl value,
    $Res Function(_$StreamingStatusChangedImpl) then,
  ) = __$$StreamingStatusChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({StreamingStatus status});
}

/// @nodoc
class __$$StreamingStatusChangedImplCopyWithImpl<$Res>
    extends
        _$SeparatedRestartableCheckInEventCopyWithImpl<
          $Res,
          _$StreamingStatusChangedImpl
        >
    implements _$$StreamingStatusChangedImplCopyWith<$Res> {
  __$$StreamingStatusChangedImplCopyWithImpl(
    _$StreamingStatusChangedImpl _value,
    $Res Function(_$StreamingStatusChangedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? status = null}) {
    return _then(
      _$StreamingStatusChangedImpl(
        status:
            null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                    as StreamingStatus,
      ),
    );
  }
}

/// @nodoc

class _$StreamingStatusChangedImpl implements StreamingStatusChanged {
  const _$StreamingStatusChangedImpl({required this.status});

  @override
  final StreamingStatus status;

  @override
  String toString() {
    return 'SeparatedRestartableCheckInEvent.streamingStatusChanged(status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StreamingStatusChangedImpl &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, status);

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StreamingStatusChangedImplCopyWith<_$StreamingStatusChangedImpl>
  get copyWith =>
      __$$StreamingStatusChangedImplCopyWithImpl<_$StreamingStatusChangedImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(ConnectionState connectionState)
    connectionStateChanged,
    required TResult Function(CameraStatus status) cameraStatusChanged,
    required TResult Function(CameraController? controller)
    cameraControllerChanged,
    required TResult Function(StreamingStatus status) streamingStatusChanged,
  }) {
    return streamingStatusChanged(status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(ConnectionState connectionState)? connectionStateChanged,
    TResult? Function(CameraStatus status)? cameraStatusChanged,
    TResult? Function(CameraController? controller)? cameraControllerChanged,
    TResult? Function(StreamingStatus status)? streamingStatusChanged,
  }) {
    return streamingStatusChanged?.call(status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(ConnectionState connectionState)? connectionStateChanged,
    TResult Function(CameraStatus status)? cameraStatusChanged,
    TResult Function(CameraController? controller)? cameraControllerChanged,
    TResult Function(StreamingStatus status)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (streamingStatusChanged != null) {
      return streamingStatusChanged(status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionStateChanged value)
    connectionStateChanged,
    required TResult Function(CameraStatusChanged value) cameraStatusChanged,
    required TResult Function(CameraControllerChanged value)
    cameraControllerChanged,
    required TResult Function(StreamingStatusChanged value)
    streamingStatusChanged,
  }) {
    return streamingStatusChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult? Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult? Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult? Function(StreamingStatusChanged value)? streamingStatusChanged,
  }) {
    return streamingStatusChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionStateChanged value)? connectionStateChanged,
    TResult Function(CameraStatusChanged value)? cameraStatusChanged,
    TResult Function(CameraControllerChanged value)? cameraControllerChanged,
    TResult Function(StreamingStatusChanged value)? streamingStatusChanged,
    required TResult orElse(),
  }) {
    if (streamingStatusChanged != null) {
      return streamingStatusChanged(this);
    }
    return orElse();
  }
}

abstract class StreamingStatusChanged
    implements SeparatedRestartableCheckInEvent {
  const factory StreamingStatusChanged({
    required final StreamingStatus status,
  }) = _$StreamingStatusChangedImpl;

  StreamingStatus get status;

  /// Create a copy of SeparatedRestartableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StreamingStatusChangedImplCopyWith<_$StreamingStatusChangedImpl>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DroppableCheckInEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toggleDebugMode,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? toggleDebugMode,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toggleDebugMode,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ToggleDebugMode value) toggleDebugMode,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ToggleDebugMode value)? toggleDebugMode,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ToggleDebugMode value)? toggleDebugMode,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DroppableCheckInEventCopyWith<$Res> {
  factory $DroppableCheckInEventCopyWith(
    DroppableCheckInEvent value,
    $Res Function(DroppableCheckInEvent) then,
  ) = _$DroppableCheckInEventCopyWithImpl<$Res, DroppableCheckInEvent>;
}

/// @nodoc
class _$DroppableCheckInEventCopyWithImpl<
  $Res,
  $Val extends DroppableCheckInEvent
>
    implements $DroppableCheckInEventCopyWith<$Res> {
  _$DroppableCheckInEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DroppableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ToggleDebugModeImplCopyWith<$Res> {
  factory _$$ToggleDebugModeImplCopyWith(
    _$ToggleDebugModeImpl value,
    $Res Function(_$ToggleDebugModeImpl) then,
  ) = __$$ToggleDebugModeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ToggleDebugModeImplCopyWithImpl<$Res>
    extends _$DroppableCheckInEventCopyWithImpl<$Res, _$ToggleDebugModeImpl>
    implements _$$ToggleDebugModeImplCopyWith<$Res> {
  __$$ToggleDebugModeImplCopyWithImpl(
    _$ToggleDebugModeImpl _value,
    $Res Function(_$ToggleDebugModeImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DroppableCheckInEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ToggleDebugModeImpl implements ToggleDebugMode {
  const _$ToggleDebugModeImpl();

  @override
  String toString() {
    return 'DroppableCheckInEvent.toggleDebugMode()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ToggleDebugModeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toggleDebugMode,
  }) {
    return toggleDebugMode();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? toggleDebugMode,
  }) {
    return toggleDebugMode?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toggleDebugMode,
    required TResult orElse(),
  }) {
    if (toggleDebugMode != null) {
      return toggleDebugMode();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ToggleDebugMode value) toggleDebugMode,
  }) {
    return toggleDebugMode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ToggleDebugMode value)? toggleDebugMode,
  }) {
    return toggleDebugMode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ToggleDebugMode value)? toggleDebugMode,
    required TResult orElse(),
  }) {
    if (toggleDebugMode != null) {
      return toggleDebugMode(this);
    }
    return orElse();
  }
}

abstract class ToggleDebugMode implements DroppableCheckInEvent {
  const factory ToggleDebugMode() = _$ToggleDebugModeImpl;
}
